# Tidy data visualization

In this chapter, we will be delving into the data visualization R package
called [_ggplot2_](https://ggplot2.tidyverse.org), which is possibly the
most famous piece of the _tidyverse_ ecosystem. So much so that people who
otherwise don't use any _tidyverse_ functions (or even who don't even use
R for data analysis itself) still use _ggplot2_ for making figures. It really
is that good.

---

**First, let's start from a clean slate, and leverage our beautiful
modularized pipeline. Create a new R script in RStudio, (`File` `->`
`New file` `->` `R Script`) and save it somewhere on your computer as
`tidy-viz.R` (`File` -> `Save`). Copy the following bit of code which
will execute your IBD and metadata processing pipeline. The rest of this
exercise will pick up with the analysis of your processed, filtered, and
merged IBD data set.**

```{r}
#| eval: false
source("ibd_utils.R")

metadata <- process_metadata()
ibd_segments <- process_ibd(bin_step = 10000)

ibd_merged <- join_metadata(ibd_segments, metadata)
```

```{r}
#| echo: false
source(here::here("files/repro/ibd_utils.R"))

metadata <- process_metadata(bin_step = 10000)
ibd_segments <- process_ibd()

ibd_merged <- join_metadata(ibd_segments, metadata)
```


An important, powerful, and even elegant concept with building visualizations
using _ggplot2_ is the idea of _layering_. Let's start to introduce this
from the simplest possible kind of visualization, which is plotting
the counts of observations of a categorical (i.e. discrete) variable.

## Exercise 1: Distribution of a categorical variable

Let's start very simply, and introduce the layering aspect of _ggplot2_
visualization package step by step. **Our data frame has a column `age_bin`,
which contains the assignment of each individual into a respective time
period. Let's start by visualizing the count of individuals in each time bin.**

#### `geom_bar()`

```{r}
ggplot(metadata)
```

```{r}
ggplot(metadata, aes(x = age_bin))
```

```{r}
ggplot(metadata, aes(x = age_bin)) + geom_bar()
```

**Let's add more layers! Use a `xlab()` function to add an x-axis label
element using the `+` operator.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Just as we did with _tidyverse_ `%>%` data transformation pipelines, as a
_ggplot2_ visualization pipeline gets more complex, it's a good idea to
introduce indentation so that each visualization steps is on its own line.

```{r}
ggplot(metadata, aes(x = age_bin)) +
  geom_bar() +
  xlab("Time period [years before present]")
```

:::

---

**Now continue adding y-axis label with the `ylab()` function.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ggplot(metadata, aes(x = age_bin)) +
  geom_bar() +
  xlab("Time period [years before present]") +
  ylab("Number of individuals")
```

:::

---

**Give your figure a proper main title using the function `ggtitle()`.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ggplot(metadata, aes(x = age_bin)) +
  geom_bar() +
  xlab("Time period [years before present]") +
  ylab("Number of individuals") +
  ggtitle("Distribution of sample counts in each time period")
```

:::

---

**Although individual functions `xlab()`, `ylab()`, `ggtitle()` are useful,
oftentimes it's better to use a general function `labs()`. Look up its
documentation under `?lab`, then rewrite the code for your figure to use
only this function, replacing your uses of `xlab()`, `ylab()`, and `ggtitle()`
just with `labs()`. Note that the function has other useful arguments -- go
ahead and use as many of them as you want.**

**Note:** Don't worry about making your figure cluttered, this is just for
practice. In a real paper, you wouldn't use title or caption directly in a
_ggplot2_ figure, but it's definitely useful for work-in-progress reports at
meetings, etc.

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ggplot(metadata, aes(x = age_bin)) +
  geom_bar() +
  labs(
    y = "Number of individuals",
    x = "Time period [years before present]",
    title = "Distribution of sample counts in each time period",
    subtitle = "Counts for individuals in 1000 Genomes Project and MesoNeo data",
    caption = "Here is an optional caption for the figure, similarly to what
      you might do in a real scientific article as a more detailed description of
      of what is going on in the plot."
  )
```

:::

---

**You can see that the "present-day" bin completely overwhelms the number of
individuals in the oldest bins. This often happens with data which follow
a more or less exponential scale. A useful trick is adding a `+ scale_y_log()`
layer. You can probably guess what it does, so try adding it to your code!**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Of course, this function transforms the y-axis on the logarithmic scale! Very
useful!

```{r}
ggplot(metadata, aes(x = age_bin)) +
  geom_bar() +
  labs(
    y = "Number of individuals",
    x = "Time period [years before present]",
    title = "Distribution of sample counts in each time period",
    subtitle = "Counts for individuals in 1000 Genomes Project and MesoNeo data",
    caption = "Here is an optional caption for the figure, similarly to what
      you might do in a real scientific article as a more detailed description of
      of what is going on in the plot."
  ) +
  scale_y_log10()
```

:::

---

**Does the order of adding layers with the `+` operator matter? Do a little
experiment to figure it out!**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

No, generally, it doesn't. This is another very useful feature of _ggplot2_.
Remember that a huge important part of an R data science workflow is interactive
communication with an R console. You can start with a little bit of code
which produces a basic outline of your figure and continue adding useful bits
and pieces to it, modifying the outcome as you go. Almost like an artist!

:::

---

It's useful to keep in mind that you can always pipe a data frame
into a `ggplot()` function using the `%>%` operator, which always places that
table as the first argument in the `ggplot()` call, where the function
expects it. I.e., instead of writing `ggplot(metadata, aes(...))`, you can also
do `metadata %>% ggplot(aes(...))`. This allows you to transform or summarize
data before plotting, which makes the combination of _tidyverse_ and _ggplot2_
infinitely stronger.

**As a refresher and for a bit more practice, `filter()` the metadata first
for individuals who are 10000 years or older, discarding the rest. Then pipe
this `filter()` result into your `ggplot()` code, keeping the plotting part
exactly the same.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
metadata %>%
filter(age > 10000) %>%
ggplot(aes(x = age_bin)) +
  geom_bar() +
  labs(
    y = "Number of individuals",
    x = "Time period [years before present]",
    title = "Distribution of sample counts in each time period",
    subtitle = "Counts for individuals in 1000 Genomes Project and MesoNeo data",
    caption = "Here is an optional caption for the figure, similarly to what
      you might do in a real scientific article as a more detailed description of
      of what is going on in the plot."
  )
```

:::

Believe it or not, with this basic structure of _ggplot2_ visualization and
combining this with any other type of _tidyverse_ manipulation, filtering, and
(as we'll later see), summarization, you're ready to make any figure imaginable.
Let's take this one step further.

---

## Exercise 2: Distribution of a numerical variable

In the previous exercise you visualized a distribution of a categorical
variable, specifically the counts of samples in an age category.
Now let's look at continuous variables and this time consider our `ibd`
table if IBD segments between pairs of individuals:

```{r}
tail(ibd_merged)
```

The most interesting quantity we might want to analyse in the IBD context
is the `length` of IBD segments, which can indicate the degree of genetic
affinity or relatedness between individuals. So let's take a look at the 
distribution of IBD lengths across our data set as an opportunity to introduce
new functionality and useful tricks of _ggplot2_.

#### `geom_histogram()` and `geom_density()`

You can visualize a distribution of values using the functions `geom_histogram()`
and `geom_density()`. Both are useful for similar things, each has its strengths
and weaknesses from a visualization perspective.

**Visualize the distribution of `length` values across all individuals in your
IBD data set, starting with the basic simple patterns of:**

1. `ggplot() + geom_histogram()`, or
2. `ggplot() + geom_density()`,

**just like you did in the previous `geom_bar()` example. Of course, you have to
fill in the `aes()` accordingly. Try to use the knowledge you obtained in the
previous exercise! As a reminder, the `length` is expressed in units of
centimorgans, so add immediately an x-axis label clarifying the units to
anyone looking at your figure, either using `xlab()` or `labs(x = ...)`.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Here's a histogram:

```{r}
ibd_merged %>%
  ggplot(aes(length)) +
  geom_histogram() +
  labs(x = "IBD length [centimorgans]")
```

Here's a density plot:

```{r}
ibd_merged %>%
  ggplot(aes(length)) +
  geom_density() +
  labs(x = "IBD length [centimorgans]")
```

:::

---

**To make our data exploration a little easier at the beginning, let's create
a new variable `ibd_eur` from the total `ibd` data, with the following
transformations:**

1. `filter()` for `region_pair == "Europe:Europe"`
2. `filter()` for `time_pair == "present-day:present-day"`

**Save the result of both filtering steps as `ibd_eur`, and feel free to use
the `%>%` pipeline concept that you learned about previously.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

This should be easy for you now as budding _tidyverse_ data munging experts!

```{r}
ibd_eur <-
  ibd_merged %>%
  filter(
    region_pair == "Europe:Europe" &
    time_pair == "present-day:present-day"
  )

ibd_eur
```

Note that I always like to indent individual steps of a data processing
pipeline so that each component is on its separate line. It helps with
readability a lot!

:::

---

**Now visualize the distribution of lengths in the reduced, Europe-only
IBD data set stored in the `ibd_eur` variable. Do this in two versions again,
using `geom_histogram()` or `geom_density()`. Additionally, for each of the
two functions specify either `fill` or `color` (or both of them!) based on the
variable `country_pair`. Experiment with the looks of the result and find
your favourite (prettiest, cleanest, easiest to interpret, etc.).**

**How do you compare these different approaches? When does one seems more
appropriate than other?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

1. Histogram version with `fill` set (I personally don't find the `color`
version of histograms useful at all so I'm not showing it here):

```{r}
ibd_eur %>%
  ggplot(aes(length, fill = country_pair)) +
  geom_histogram() +
  labs(x = "IBD segment length [centimorgans]")
```

2. Density versions:

- using `color` only:

```{r}
ibd_eur %>%
  ggplot(aes(length, color = country_pair)) +
  geom_density() +
  labs(x = "IBD segment length [centimorgans]")
```

- using `fill`, which also requires setting the `alpha` transparency to avoid
accidentally hiding some peaks:

```{r}
ibd_eur %>%
  ggplot(aes(length, fill = country_pair, color = country_pair)) +
  geom_density(alpha = 0.5) +
  labs(x = "IBD segment length [centimorgans]")
```

:::


### Limiting axis scales

Above, we clearly have some individual pairs which share a huge amount of IBD.
We'll quantify how much a bit later, but for now, the x-axis appears in the
density plot is too spread out. This happens often in visualizing numerical
variables. **Use these two additional layers to improve the readability of
your figures by restricting the range of the x-axis of your figures:**

1. Add this layer `+ xlim(0, 10)` to your figure,
2. or this layer `+ coord_cartesian(xlim = c(0, 10))`.

**What's the difference between both possibilities?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Here are the two versions of restricting the x-axis scale. Note that they
differ only by the command used at the 5th line!

1. `coord_cartesian()` performs so-called "soft clipping" -- it restricts the
"viewpoint" on the entire data set:

```{r}
#| code-line-numbers: true
ibd_eur %>%
  ggplot(aes(length, color = country_pair)) +
  geom_density() +
  labs(x = "IBD segment length [centimorgans]") +
  coord_cartesian(xlim = c(0, 10))
```

2. `xlim()` does "hard clipping" -- it effectively removes the points outside
of the given range. This usually isn't what we want, so I personally rarely
if ever use this:

```{r}
#| code-line-numbers: true
ibd_eur %>%
  ggplot(aes(length, color = country_pair)) +
  geom_density() +
  labs(x = "IBD segment length [centimorgans]") +
  xlim(0, 10)
```

Admittedly they both give the same result, but that's not always the case, so
be careful!

:::

---

**Is there evidence of some countries sharing more IBD sequence
_within themselves_. If that's the case, it could be a result of a stronger
population bottleneck. The previous density plot is a little too busy to
be able to see this, so filter your `ibd_eur` table for rows in which
`country1` is the same as `country2`, and then %>% pipe it into the
usual _ggplot2_ density command.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd_eur %>%
  filter(country1 == country2) %>%
  ggplot(aes(length, color = country_pair)) +
  geom_density() +
  labs(x = "IBD segment length [centimorgans]") +
  xlim(0, 10)
```

It looks like there are more IBD sequence shared within Finland, which is
consistent with a
[previously established hypothesis](https://en.wikipedia.org/wiki/Finnish_heritage_disease)
that ancestors of present-day Finns experienced a strong popularion bottleneck.

:::

---

**Let's introduce another useful geom for visualization of this type of
numerical data, the boxplot! You can visualize boxplots with the function
`geom_boxplot()`, and calling (in our case right here)
`aes(x = country_pair, y = length, color = country)` within the `ggplot()`
function. Adjust your previous density example according to these instructions
to show boxplots instead!**

**When you have your boxplots, swap out `geom_boxplot()` for `geom_violin()`.**

**Note:**  Hopefully you can see now how super modular and customizable
_ggplot2_ for making many different types of visualizations!

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd_eur %>%
  filter(country1 == country2) %>%
  ggplot(aes(x = country_pair, y = length, color = country_pair)) +
  geom_boxplot() +
  labs(y = "IBD segment length [centimorgans]") +
  ylim(0, 10)
```

```{r}
ibd_eur %>%
  filter(country1 == country2) %>%
  ggplot(aes(x = country_pair, y = length, color = country_pair)) +
  geom_violin() +
  labs(y = "IBD segment length [centimorgans]") +
  ylim(0, 10)
```

:::


I'm personally a much bigger fan of the violin plot for this kind of purpose,
because I feel like boxplot hides too much about the distribution of the data.

**On that note, another useful trick we haven't mentioned yet is that we can
plot multiple geoms from the same data! You're already quite familiar with
the _ggplot2_ concept of layering functions on top of each other using the `+`
operator. What happens when you add `+ geom_jitter(size = 0.3, color = "darkgray")` after the
line with `geom_violin()`? How do you read the resulting figure?**

**Note:** We specified `color = "darkgray"`, which effectively overrides
the `color = country_pair` assigned in the `ggplot()` call (and which normally
sets the color for every single geom we would add to our figure).

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

`geom_jitter()` is extremely useful to really clearly see the true distribution
of our data points (which is often otherwise hidden by the "summarizing geoms",
such as boxplot above -- one reason why I'm not a fan of boxplots, as I 
mentioned!):

```{r}
ibd_eur %>%
  filter(country1 == country2) %>%
  ggplot(aes(x = country_pair, y = length, color = country_pair)) +
  geom_violin() +
  geom_jitter(size = 0.3, color = "darkgray") +
  labs(y = "IBD segment length [centimorgans]") +
  ylim(0, 10)
```

:::

---

**What do you think happens when you exchange the order of `geom_violin()`
and `geom_jitter(...)` in your previous solution? Why does the order matter?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

_ggplot2_ arranges elements on a canvas literally like a painter would,
if an element is added and another element is added later, the latter can
(partially) overlap the former:

```{r}
ibd_eur %>%
  filter(country1 == country2) %>%
  ggplot(aes(x = country_pair, y = length, color = country_pair)) +
  geom_jitter(size = 0.3, color = "darkgray") + # we flipped the order
  geom_violin() +                               # of these two geoms
  labs(y = "IBD segment length [centimorgans]") +
  ylim(0, 10)
```

Of course, this can also be intentional sometimes! It all depends on the
aesthetic you're going for as a visualization artist. :)

:::


## Exercise 3: Relationship between two variables

#### `geom_point()`

We'll now look at creating another type of visualization which is extremely
useful and very common: a [scatter plot](https://en.wikipedia.org/wiki/Scatter_plot)!

But first, let's do some more data summarization so that we can demonstrate
building of scatter plots using _ggplot2_. At this point, this should all be
a piece of cake for you!

The previous figures showed distributions of individual segment lengths
on present-day individuals only. Another useful quantity is the number of
segments shared between a pair of individuals and the total number of IBD
sequence between those pairs.

**Practice your knowledge of `group_by()` and `summarize()` and apply them
to our huge `ibd_segments` table, to achieve the following:**

0. Start with our original big IBD table `ibd_segments` (not the smaller `ibd_eur`!)

1. `filter()` for rows in which `region_pair == "Europe:Europe"` (only pairs
within Europe, just as we did before),

2. `filter()` for rows in which `length > 10` (only long IBD segments)

3. `filter()` for rows in which `age_bin1 == age_bin2` (only individuals from
the same age bin),

4. `group_by()` to create groupings based on `sample1`, `sample2`,
`country_pair`, `region_pair`, and `time_pair`,

5. `summarize()` to create two new quantities `n_ibd = n()` and `total_ibd = sum(length)` (total number of long IBD segments and their total sequence for each
of individuals).

**Save the result of your `%>%` pipeline implementing the steps 1.-3. above in
a variable `ibd_sum`.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Again, once you know the functions `filter()`, `group_by()`, and `summarize()`,
implementing the pipeline is just a matter of sequencing them together as if
you were building a LEGO set!

```{r}
ibd_sum <-
  ibd_merged %>%
  filter(
    length > 10 &          # only long IBD segments
    age_bin1 == age_bin2   # only IBD pairs within the same time window
  ) %>% 
  group_by(sample1, sample2, rel, country_pair, region_pair, time_pair) %>%
  summarize(n_ibd = n(), total_ibd = sum(length))

ibd_sum
```

I hope you're all appreciating the awesome data science powers you've already
learned to do this! This would require a crazy amount of work with standard
base R and might be very hard (or downright impossible) to do with Excel.

Believe me that if you understand this particular chunk of code (even if
you needed help putting it together) you know the majority of _tidyverse_
work needed to answer complex data science questions.

:::

---

**Your work so far has been based on a small subset of the overall IBD
data, just for chromosome `r unique(ibd_segments$chrom)`. To move to more complex
and interesting visualization, execute this command which reads the `ibd_long`
just like you created it yourself, except based on all chromosomes in the
entire genome. We'll be working on that from now on.**

```{r}
ibd_sum <- read_tsv("http://tinyurl.com/simgen-ibd-sum")
```


---

With our summarized table `ibd_sum` ready, we're ready to create our
scatter plot. When we worked with `geom_histogram()`, `geom_density()`, and
`geom_bar()`, we only needed to do something like this:

```{r}
#| eval: false
df %>%
  ggplot(aes(x = COLUMN_NAME)) +
  geom_FUNCTION()
```

Because scatter plot is two-dimensional, we have to specify
not only the `x` but also the `y` in the `aes()` aesthetic mapping... and with
that bit of information, I think you already know how to do this based
on your knowledge of basic _ggplot2_ techniques introduced above!

**Use the function `geom_point()` to visualize the scatter plot of
`x = total_ibd` against `y = n_ibd`. We know that related individuals share
a large amounts of IBD sequence between each other. As a reminder, the entire
human genome spans about 3000 centimorgans. Can you guess from your figure
which pairs of individuals (a point on your figure representing one such pair)
could be potentially closely related?**

**Note:** Don't worry about this too much, just take a guess. Below we'll look
at this question more closely.

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

It looks like some pairs of individuals share almost their entire genome in
IBD, around the whole 3 gigabases of sequence!

We'll work on clarifying that below.

```{r}
ibd_sum %>%
  ggplot(aes(x = total_ibd, y = n_ibd)) +
  geom_point()
```

:::

---

**From the introduction of histograms and densities, you're already familiar
with modifying the `aes()` aesthetic of a geom layer using the `color`
argument of `aes()`. Right now your dots are all black, which isn't super
informative. Luckily, you're IBD table has a "mysterious" column called
`rel`. What happens when you `color` points based on the values in this
column inside the `aes()` function (i.e., set `color = rel`)? Similarly,
what happens when you set `shape = rel`?**

**Look at a figure from [this huge](https://www.nature.com/articles/s41588-023-01582-w/figures/3)
study of IBD patterns and their relationship to the degree of relatedness
between individuals? This is completely independent data set and independent
analysis, but do you see similarities between this paper and your figure?**

---

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd_sum %>%
  ggplot(aes(x = total_ibd, y = n_ibd, color = rel)) +
  geom_point()
```

:::

I have to say I kind of hate that "none" (basically an baseline background)
is given a striking purple. I woudln't want that in my paper, and we will
show a potential solution to this soon! For now, let's keep going.

---


**We're approching something which isn't far from a publication quality
figure. To get even closer, use the `+ labs()` layer function to properly
annotate your `x` and `y` axes, and give your figure a nice `title` too.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd_sum %>%
  ggplot(aes(x = total_ibd, y = n_ibd, color = rel)) +
  geom_point() +
  labs(x = "total IBD sequence", y = "number of IBD segments",
       title = "Total IBD sequence vs number of IBD segments",
       subtitle = "Both quantities computed only on IBD segments 10 cM or longer")
```

:::

## Exercise 4: Multiple data sets in one plot

So far we've always followed this pattern of _ggplot2_ usage, to borrow our
very first `geom_histogram()` example just for the sake of explanation:

```{r}
ggplot(ibd_segments, aes(length)) +
  geom_histogram()
```

However, you can also do this and it will give the same result (**try it!**):

```{r}
ggplot() +
  geom_histogram(data = ibd_segments, aes(length))
```

In other words, each `geom_<...>()` function accepts both `data` data frame
and also its own `aes()` aesthetic and mapping function. You could think of
this as each individual geom having a "self-contained" `ggplot()` function's
ability.

This can be very useful whenever we want to plot different aspects of the data
with their own aesthetic parameters (colors, shapes, sizes). Let's work through
an exercise to explain this better, step by step, to make our IBD scatter plot
figure much more nicer to look at.

---

Above I complained a little bit how the "none" related data points are
given just as strikingly colorful points as data points of interest. What we
want to establish is different visual treatments of different kinds of data.
Here's one solution to do this (which will also demonstrate a very very
useful _ggplot2_ trick).

**First, take your `ibd_sum_total` table and create two versions of it
using `filter()` like this:**

1. `ibd_unrel <- filter(ibd_sum, rel == "none")`
2. `ibd_rel <- filter(ibd_sum, rel != "none")`

The first table contains only those pairs of individuals with missing information
about relatedness, the second one contains only those rows with this information
present.

**Print out the `ibd_unrel` and `ibd_rel` tables to make sure they both
contain the same columns, even though they have different rows.**


::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd_unrel <- filter(ibd_sum, rel == "none")
ibd_unrel
```

```{r}
ibd_rel <- filter(ibd_sum, rel != "none")
ibd_rel
```

:::

---

**Then visualize the `ibd_unrel` (IBD summaries between unrelated individuals)
table with the following "template".**

**Note:** The `ggplot()` has no arguments! Everything is in the `geom_point()`
call!

```
ggplot() +
  geom_point(data = <DATA FRAME>, aes(<ADD WHAT IS NEEDED>), color = "lightgray")
```

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ggplot() +
  geom_point(data = ibd_unrel, aes(x = n_ibd, y = total_ibd), color = "lightgray")
```

:::

---

**Now visualize the scatter plot of pairs of individuals which are known to be
related, `ibd_rel`, so something looking like this:**

```
ggplot() +
  geom_point(data = <DATA FRAME>, aes(<ADD WHAT IS NEEDED>, color = rel)) +
```

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ggplot() +
  geom_point(data = ibd_rel, aes(x = n_ibd, y = total_ibd, color = rel))
```

:::

---

**You have now plotted the two scatter plots separately, but here comes a very
cool aspect of _ggplot2_ I wanted to show you. You can combine the two figures,
each plotting a different data frame, into one! Do this now and to make the
figure even nicer (and even publication ready!), add proper `x` and `y` labels,
overall plot `title` as well as `subtitle` (all using the `labs()` layer
functions) as well as adjust the legend title (just like you did with the
`guides()` layer function above).**

**As a bonus, and to learn another parameter of `aes()` useful for scatter plots,
in addition to setting `color = rel` (which sets a color of each point based
on the relatedness value), add also `shape = rel`! Observe what happens
when you do this!**

**Similarly, in the `geom_point()` command plotting unrelated individuals,
in addition to setting `color = "lightgray"`, set also `size = 0.75`.**

**I'm not personally fan of the default grey-filled background of ggplots.
I like to add `+ theme_minimal()` at the end of my plotting code of many of
my figures, particularly when I'm creating visualizations for my papers.
Try it too!**

**Hint:** If it still isn't clear, don't worry. Here's a bit of help of what
your plotting code should look like:

```
ggplot() +
  geom_point(<YOUR CODE PLOTTING UNRELATED IBD PAIRS>)
  geom_point(<YOUR CODE PLOTTING RELATED IBD PAIRS>) +
  labs(<x, y, title, and subtitle text>) +
  guides(color = guide_legend("relatedness"), shape = guide_legend("relatedness)) +
  theme_minimal()
```


::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Here's the complete solution to this exercise:


```{r}
ibd_unrel <- filter(ibd_sum, rel == "none")
ibd_rel <- filter(ibd_sum, rel != "none")

ggplot() +
  geom_point(data = ibd_unrel, aes(x = total_ibd, y = n_ibd), color = "lightgray", size = 0.75) +
  geom_point(data = ibd_rel, aes(x = total_ibd, y = n_ibd, color = rel, shape = rel)) +
  labs(
    x = "total IBD sequence",
    y = "number of IBD segments",
    title = "Total IBD sequence vs number of IBD segments",
    subtitle = "Both quantities computed only on IBD segments 10 cM or longer"
  ) +
  guides(
    color = guide_legend(title = "relatedness"),
    shape = guide_legend(title = "relatedness")
  ) +
  theme_minimal()
```

:::

## Exercise 4: Categories in facets (panels)

Let's talk about dimensionality (i.e., the number of variables) in our data
sets and about the ways we can represent them. This topic boils down to the
question of _"How many dimensions of our data can we represent in a single
figure and be it as comprehensible as possible?"_

So far we've managed to visualize a rather complex data set, which features,
for pairs of two individuals:

- the total amount of IBD sequence `total_ibd` (plotted on the **x axis**)
- the number of IBD segments `n_ibd` (plotted on the **y axis**)
- the degree of relatedness `rel` (plotted as **colors** and **shapes**)

Just look at this figure again -- this could easily be a main figure in a
final scientific publication and we only needed a few lines of nicely
readable code!

```{r}
#| echo: false
ibd_unrel <- filter(ibd_sum, rel == "none")
ibd_rel <- filter(ibd_sum, rel != "none")

ggplot() +
  geom_point(data = ibd_unrel, aes(x = total_ibd, y = n_ibd), color = "lightgray", size = 0.75) +
  geom_point(data = ibd_rel, aes(x = total_ibd, y = n_ibd, color = rel, shape = rel)) +
  labs(
    x = "total IBD sequence",
    y = "number of IBD segments",
    title = "Total IBD sequence vs number of IBD segments",
    subtitle = "Both quantities computed only on IBD segments 10 cM or longer"
  ) +
  guides(
    color = guide_legend(title = "relatedness"),
    shape = guide_legend(title = "relatedness")
  ) +
  theme_minimal()
```

Now looking at the data again, we see additional variables (data dimensions).
What if we want to visualize the `time_pair` variable, and observe the patterns
of IBD sharing across time? We have run out of possibilities of visualizing
them using the means that we have available(`x` and `y` dimensions, `color`
and `shape`). The answer can be _facetting_.

```{r}
head(ibd_sum)
```

**Faceting is easier to demonstrate than explain, so just go ahead, take
your publication-quality scatter plot figure and add `+ facet_wrap(~ time_pair)`
at the end of your code chunk. What do you see? How do you interpret the
result?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
#| echo: false
ibd_unrel <- filter(ibd_sum, rel == "none")
ibd_rel <- filter(ibd_sum, rel != "none")

ggplot() +
  geom_point(data = ibd_unrel, aes(x = total_ibd, y = n_ibd), color = "lightgray", size = 0.75) +
  geom_point(data = ibd_rel, aes(x = total_ibd, y = n_ibd, color = rel, shape = rel)) +
  labs(
    x = "total IBD sequence",
    y = "number of IBD segments",
    title = "Total IBD sequence vs number of IBD segments",
    subtitle = "Both quantities computed only on IBD segments 10 cM or longer"
  ) +
  guides(
    color = guide_legend(title = "relatedness"),
    shape = guide_legend(title = "relatedness")
  ) +
  theme_minimal() +
  facet_grid(~ region_pair)     # <-- THIS IS THE ONLY THING WE ADDED!
```

:::


### Combining figures

TODO: Logscale vs normal scale

So, here's an extremely cool revelation. Do you remember how we went through
various data types and object classes in the R bootcamp? Numeric, logical,
character types, etc?

_ggplot() functions actually do return a (hidden) value, which is a normal
object like any other R value!_ The fact that we immediately see a plot
visualized is "just" a side effect that R provides for convenience! After
all, when we write plotting code, we usually want to see the plot, right?

What does this mean? Well, first of all, consider this bit of code:

```{r}
p1 <- ggplot()
```

Weird, huh? Why would you do that? **When you type `p1` in your R console
you get the usual (empty) figure!**

```{r}
p1
```

Of course, we can also create (and save in a variable) a full figure like this:

```{r}
p1 <- ggplot(ibd_segments, aes(length)) + geom_histogram()
p1
```

We could also create and save another figure, this time a density:

```{r}
p2 <- ggplot(ibd_segments, aes(length)) + geom_density()
p2
```

This is extremely useful for making composite figures built out of individual
panels (like you often see in scientific figures as panels **A**, **B**, **C**,
etc.). The way we can do this is using a helper R package _cowplot_ (don't
ask me about its name, I have no idea! :)) and its function `plot_gri()`. **Check
this out:**

```{r}
library(cowplot)

plot_grid(p1, p2, labels = c("A", "B"))
```

This is an extremely useful pattern because it basically eliminates the need
for manually pasting figures in a graphics editor (which defies the purpose
of reproducibility!). The sky is actually a limit, because you can place
other `plot_grid()` calls within another `plot_grid()`, composing figures
of various levels of complexity. Check out
[a figure from one of my papers](https://github.com/bodkan/archaic-ychr/blob/master/figures/fig1.pdf),
each panel is an independently made _ggplot2_ figure, all pasted together
with `plot_grid()`. 

For instance, if we make `p3` like this:

```{r}
# create a silly scatter plot of geographical coordinates of our samples
# (do you see an outline of Europe? :))
p3 <-
  metadata %>%
  filter(continent == "Europe") %>%
  ggplot(aes(longitude, latitude)) +
    geom_point()
p3
```

**You could combine them like this** (this is just an example, don't read too
much into the meaning of putting these particular plots together).

```{r}
plot_grid(
  p3,
  plot_grid(p1, p2, labels = c("B", "C")),
  nrow = 2,
  labels = "A"
)
```



```{r}
ibd_sum %>%
  filter(region_pair == "Europe:Europe") %>% 
  ggplot(aes(time_pair, total_ibd)) +
  geom_violin() +
  theme(axis.text.x = element_text(hjust = 1, angle = 45))
```




## Bonus exercises




## Further practice

### Option 1: Your own data

I'm sure you have done some form of table munging and data visualization in your
projects. If you're done with the exercises above, here are some ideas for you:

1. If you haven't used R for processing of tabular data in your work -- maybe
you have done similar table munging in Excel or Google Sheets in a manual
(i.e., non-reproducible) way? -- write your processing steps as a self-contained
R script:

- If you used Excel, you can use the R package [_readxl_](https://readxl.tidyverse.org),
- If you used Google Sheets, you can use the R package [_googlesheets4_](https://googlesheets4.tidyverse.org)

2. If you used Excel or base R for plotting figures, use what you learned
about _ggplot2_ to make beautiful, publication-ready plots as we did in our
exercises.

Yes, this will put you in an uncharted territory. This is scary and totally
normal when doing research. I'm happy to help you out with questions
and issues!

### Option 2: Star Wars characters

If you need a break from population genetics and biology and would still
like to practice your _tidyverse_ and _ggplot2_ skills, here's a fun data
set for you with various metadata about Star Wars characters, with a list
of questions you can try answering. Every single question can be answered
using the tools you've already encountered here!

```{r}
library(dplyr)

starwars
```

1. What is the distribution of counts of sexes of the characters?
2. What is the distribution of counts of genders of the characters?
3. Who is the oldest character?
4. Who is youngest?
5. What's the most frequently featured homeworld planet?
6. What is the weight of Jar Jar Binks?

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

This is way too many questions to provide solutions too with extensive comments.
Luckily, you should be able to guess which code answers which question in which
way, so just experiment!

```{r}
ggplot(starwars, aes(sex)) + geom_bar()
```

```{r}
ggplot(starwars, aes(gender)) + geom_bar()
```

```{r}
ggplot(starwars, aes(height)) + geom_histogram()
```

```{r}
ggplot(starwars, aes(mass)) + geom_histogram()
```

There's a clear massive (literally) outlier. Is this a data-entry error, or
could it possibly be [this guy](https://www.starwars.com/databank/jabba-the-hutt)?

```{r}
filter(starwars, mass > 1000)
```

Jabba ruins everything, so let's cap the mass scale so that we can see some
patterns:

```{r}
starwars %>%
filter(!is.na(gender)) %>%
ggplot(aes(gender, mass, fill = gender)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter() +
  coord_cartesian(ylim = c(0, 250))
```

```{r}
starwars %>%
filter(!is.na(sex)) %>%
ggplot(aes(sex, mass, fill = sex)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter() +
  coord_cartesian(ylim = c(0, 250))
```


```{r}
ggplot(starwars, aes(mass, height)) + geom_point()
```

```{r}
ggplot(starwars, aes(mass, height)) +
  geom_point() +
  coord_cartesian(xlim = c(0, 250))
```

```{r}
ggplot(starwars, aes(mass, height)) +
  geom_point() +
  geom_smooth(method = "lm") +
  coord_cartesian(xlim = c(0, 250))
```

```{r}
ggplot(starwars, aes(mass, height)) +
  geom_point() +
  geom_smooth(method = "lm") +
  xlim(c(0, 250))
  # coord_cartesian(xlim = c(0, 250))
```

:::