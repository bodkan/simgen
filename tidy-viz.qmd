# Advanced data science

In this chapter, we will be delving into the data visualization R package
called [_ggplot2_](https://ggplot2.tidyverse.org), which is possibly the
most famous piece of the _tidyverse_ ecosystem. So much so that people who
otherwise don't use any _tidyverse_ functions (or even who don't even use
R for data analysis itself) still use _ggplot2_ for making figures. It really
is that good.

**Here is how the start of our solutions script for the day will look like.**
Note the addition of `library(ggplot2)` to the list of R packages used in
the previous chapter. Although you could use _ggplot2_ without the rest,
it ties so neatly with every other part of the _tidyverse_ ecosystem that you
almost always end up using them together.

```{r}
#| message: false
library(ggplot2) # the star of the day!

library(dplyr)
library(tidyr)
library(readr)
```

**Let us also read in data which we will be using in these exercises.** These
are coordinates of identity-by-descent (IBD) segments between pairs of
individuals in a
[huge aDNA study](https://www.nature.com/articles/s41586-023-06865-0)
we've already talked about. This data is huge and quite complex -- I've
prefiltered it to contain only IBD segments for chromosome 1.

::: {.aside}
Why use IBD for these exercises? First, IBD data are increasingly
popular across population genomics and evolutionary biology, so it's very likely
you will encounter it in your own work. Second, it's an excellent data se on
which you can practice and develop your data science skills.
:::

```{r}
gz_file <- tempfile()
download.file("https://tinyurl.com/simgen-ibd", gz_file, mode = "wb", quiet = TRUE)
ibd_all <- read_tsv(gz_file, show_col_types = FALSE)
```

<!-- load("~/Desktop/neo.impute.1000g.ibd.filter.strict.RData") -->
<!-- ibd_all <- dd -->
<!-- ibd_all <- dplyr::as_tibble(ibd_all) -->
<!-- ibd_all <- dplyr::select(ibd_all, sample1, sample2, chrom = chromosome, start = posCmStart, end = posCmEnd) -->
<!-- ibd_all <- dplyr::filter(ibd_all, chrom == 1) -->
<!-- ibd_all <- dplyr::filter( -->
<!--   ibd_all, -->
<!--   sample1 != "K1" & sample2 != "K1" &  # individual without age -->
<!--   sample1 != "Denisova" & sample2 != "Denisova" & -->
<!--   sample1 != "Vindija33.19" & sample2 != "Vindija33.19" & -->
<!--   sample1 != "AltaiNeandertal" & sample2 != "AltaiNeandertal" -->
<!-- ) -->
<!-- readr::write_tsv(ibd_all, "files/tidy/ibd.tsv.gz") -->

And **we also need to read the corresponding metadata, with which you are already
very closely familiar with**:

```{r}
metadata_all <- read_tsv("https://tinyurl.com/simgen-metadata", show_col_types = FALSE)
```

**Create a new R script in RStudio, (`File` `->` `New file` `->` `R Script`) and
save it somewhere on your computer as `tidy-viz.R` (`File` -> `Save`). Copy
the two chunks of code above into it and let's get started!**

You just got a new data set from a bioinformatics software, in this case
the IBDseq software for detecting IBD segments between pairs of individuals.
Before you proceed with doing any kind of statistical analysis you need to
do two things:

1. Exploring the data to see _what_ is it that you just got.
2. Filtering and processing it in a way which will make your work easier.

Let's tackle step 1 first.

---

## Exercise 1: Exploring new data

**As a sanity check, do you have metadata information for every individual in
the `sample1` and `sample2` columns of the IBD table? What about the other
way around -- do all individuals in the metadata have some IBD relationship to
another individual? If not, find out which individuals are these.**

This is another sort of sanity checking you will be doing all the time. We can
only analyze data for which we have metadata information (population assignment,
geographical location, dating information), so let's make sure we have what we
need.

**Hint:** Another way to phrase this question is this: does every name that
appears in either `sample1` or `sample2` column of `ibd` have a record in the
`sampleId` column of `metadata` (i.e., is information in one vector of names
a perfect subset of the second vector of names)? Remember that you can use the
function `unique()` to get all unique values in a given vector (as in, all
unique values in vector `ibd$sample1` which has otherwise many duplicated
entries). And remember the existence of `%in%` and `!` operators!

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

We can get unique values across a combination of vectors by first binding
everything together using `c(ibd$sample1, ibd$sample2)` which gets us a single
vector, then calling `unique()` on that:

```{r}
ibd_samples <- unique(c(ibd_all$sample1, ibd_all$sample2))

metadata_samples <- metadata_all$sampleId
```

Then we can use our well-known operator `%in%` to check that every sample in
the IBD data has a representative in the metadata:

```{r}
all(ibd_samples %in% metadata_samples)
```

Let's also look at the inverse test:

```{r}
all(metadata_samples %in% ibd_samples)
```

Interesting, some individuals don't have any IBD with anybody else. Who are they?

```{r}
metadata_all[!metadata_samples %in% ibd_samples, ]
```

Why doesn't that ancient Danish person have any IBD with anyone is interesting,
but perhaps not a red flag we should be worrying about in our analyses. Same
goes for the Archaic individuals -- even if they had some IBD shared with
modern humans (which we would expect in principle), perhaps the author of the
IBD data set filtered those IBD segments out.

:::

---

**Which columns does the IBD data have? What's the format of the data?
What ranges or distributions of values do you have available, and with what
data types? Do you have information for the entire genome?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
head(ibd_all)
```


```{r}
glimpse(ibd_all)
```

We have information just for chromosome 1 to make the data set a little
smaller and easier for your laptops to handle.

```{r}
table(ibd_all$chrom)
```

:::


## Exercise 2: IBD processing

**Add a new column using the `mutate()` function called `length`, which contains
the length of each IBD segment in centimorgans (`end - start`). Save the result
to a new variable `ibd`.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd <- ibd_all %>% mutate(length = end - start)

ibd
```

Note that you don't always use a _tidyverse_ approach. Sometimes doing a simple
thing using a simple method is just... simpler:

```{r}
# we first make a copy of the original data
ibd <- ibd_all
# and then add the new column
ibd$length <- ibd_all$end - ibd_all$start

ibd
```

:::


---

We have processed our IBD table a bit, so let's proceed with the metadata. There's
much more information than we need for now, so let's make the data a bit smaller
and easier to look at at a glance.

**`select()` a subset of the metadata with the following columns and store it in a
variable `metadata_subset`: `sampleId`, `country`, `ageAverage`.
Then `rename()` `sampleId` to `sample`, `popId` to `pop`, and `ageAverage` to
`age` just to save ourselves some typing.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
metadata <- select(metadata_all, sample = sampleId, country, age = ageAverage)
metadata
```

:::

---

**Just as you did in the previous chapter, use `mutate()` and `if_else()` to
make sure that the "Modern" individuals have the `age` set to 0, instead of
`NA` (and everyone else's age stays the same). In other words, replace the
`NA` values of `age` with 0.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
metadata <- mutate(metadata, age = if_else(is.na(age), 0, age))
```

Let's make sure we haven't missed anything else:

```{r}
all(!is.na(metadata$age))
```

:::

---

**Our analyses will exclusively focus on modern humans. Filter out the three
archaics in the `metadata`, saving the results into the same `metadata`
variable again. As a reminder, these are individuals whose `sample` name
is among `c("Vindija33.19", "AltaiNeandertal", "Denisova")` which you can
test in a `filter()` command using the `%in%` operator.**

**Hint:** Remember that you can do not only `column %in% c(... some values...)`
but also do the opposite test as `!column %in% c(... some values...)` (notice
the `!` operator in the second version).

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
metadata <- filter(metadata, !sample %in% c("Vindija33.19", "AltaiNeandertal", "Denisova"))
```

:::

## Exercise 4: Metadata processing

We now have a cleaner IBD table looking like this:

```{r}
head(ibd)
```

And here's our metadata information:

```{r}
head(metadata)
```

Our `set` has only two values, "Modern" and "Ancient". Although useful, we
might want to do some fancier analyses later down the line, looking at IBD
as a time series.

**Let's introduce an incredibly useful function called `cut()`.
Take a look at `?cut` help page and skim through it to figure out what it does.
As a bit of a hint, we will want to add a new metadata column which will indicate
in which age bin (maybe, split in steps of 5000 years) do our individuals
belong to.**

Here's a small example to help us get started. Think about what
the `cut()` function does here based on the result it gives you.
You can pretend for now that the `ages` variable corresponds to age of our
samples in the huge `metadata` table:

```{r}
# a toy example data frame mimicking the age column in our huge metadata table
df <- data.frame(age = c(0, 0, 1000, 0, 5000, 10000, 7000, 13000, 18000, 21000, 27000, 30000))

# let's first generate the breakpoints for our bins (check out `?seq` if
# you're confused by this!)
breakpoints <- seq(0, 50000, by = 5000)
breakpoints

# binning the age into groups using our breakpoints
df$age_bin <- cut(df$age, breaks = breakpoints)

df
```

**Note:** The function `cut()` is extremely useful whenever you want to discretize
some continuous variable in bins (basically, a little similar to what
a histogram does in context of plotting). Doing statistics on this kind of
binned data is something we do very often. So never forget that `cut()` is
there to help you!

---

**In the example of the `cut()` function right above, what is the data type
of the column `age_bin` created by the `cut()` function? Use `glimpse(df)` to see
this data type, then skim through the documentation of `?factor`. Additionally,
why is the `age_bin` value equal to `NA` for some of the values? (We will fix this
later, don't worry.)**

As you're thinking about these questions, consider the two following vectors.
When you print them out in your R console (by typing `x1` and `x2`) you will
get something that looks almost identical. **What happens when you apply the
`typeof()` function on both of them? `x2` gives you a strange result -- why?
What do you get when you run the following command `levels(x2)`? What do you
get when you run `as.character(x2)`?

```{r}
x1 <- c("hello", "hello", "these", "are", "characters/strings")
x2 <- factor(x1)

x1
x2
```

**Note:** The discussion of "factors" should've been technically part of our
R bootcamp chapter, on the topic of "data types". However, that section was
already too technical, so I decided to move it here to the data analysis section,
because I think it makes more sense to explain it in a wider context.

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

The reason you get the `typeof(x1)` as "character" but `typeof(x2)` as "integer"
although both are "basically strings" is because factors are a special data
type for encoding categorical variables which can only have a set of fixed
possible values. Internally, for efficiency, levels of a factor variables
are stored as integers, and their values or just "labels" for those integers.

Importantly, factor levels are actually, which is very useful for plotting,
as we will see later.

For now, don't worry about this too much. We needed to introduce the concept
of factors because they are very frequently used whenever we need to bin
continuous data, like we will now for assigning samples into bins based
on their `age` value.

Oh, and the answer to why `cut()` gave us the `NA` for every 0 value is
because of its `include.lowest` argument is set to `FALSE`. Compare these two:

```{r}
cut(df$age, breaks = seq(0, 50000, by = 5000))
```

```{r}
cut(df$age, breaks = seq(0, 50000, by = 5000), include.lowest = TRUE)
```

However, this isn't what we want, because we want to treat present-day individuals
separately as their own category, not include them with other ancient people
less than 5000 years old.

The `levels()` function is useful for getting the "labels" of the categories
as they are presented to you in various outputs (rather than their internal
numerical encoding).

Consider the original vector `x2` (note the duplicated "hello" value):

```{r}
x2
```

And the `levels()` output:

```{r}
levels(x2)
```

When we run `as.character()`, we effectively convert the (categorical) factor
values into normal strings (i.e., basically convert those values into their
plain labels). This is very useful whenever we want to manipulate factors,
as we'll se below:

```{r}
as.character(x2)
```

:::

---

**The scientific notation format of bin labels with all those `+` is very
annoying to look at. How can you use the `dig.lab =` argument of the `cut()`
functions to make this prettier? Experiment in the R console to figure this out,
then modify the `df$age_bin <- cut(df$age, breaks = breakpoints)` command
in your script accordingly.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Let's experiment first:

```{r}
cut(df$age, breaks = breakpoints)
cut(df$age, breaks = breakpoints, dig.lab = 3)
cut(df$age, breaks = breakpoints, dig.lab = 10)
```

Our solution to get rid of the ugly scientific notation in our labels:

```{r}
df$age_bin <- cut(df$age, breaks = breakpoints, dig.lab = 10)

df
```

Much nicer to look at!

:::



---

You have now learned that `cut()` has an optional argument called
`include.lowest =`, which includes the lowest value of 0 (representing
the "present-day" age of our samples) in the lowest bin [0, 5]. However, in the
case of our assignment of samples from present-day, this is not what we want.
We want present-day individuals to have their own category called "present-day".

Here's a useful bit of code I use often for this exact purpose. If we start
from the original toy example data frame (with the `NA` values assigned to
present-day ages of 0):

```{r}
df
```

We can fix this by the following three-step process, described in the comments:

```{r}
bin_levels <- levels(df$age_bin) # 1. extract labels (no "present-day" category yet)

df <-
  df %>%
  mutate(
    age_bin = as.character(age_bin),                      # 2. convert factors into strings
    age_bin = if_else(is.na(age_bin), "present-day", age_bin) # 3. replace NA with "present-day"
  )
```

When we print the modified `df` table, we see all bins properly assigned now,
including the present-day samples with ages at 0:

```{r}
df
```

**This is a very useful pattern which you will get to practice now on the full
`metadata` table.**

---

**Now that you're familiar with `cut()`, use the functions `mutate()` and
`cut()` again to create a new column `age_bin` this time on the whole `metadata`
table. The new column should carry a category age of each individual in steps of
2000 years again. Use the example from above to do this. Use `table(metadata$age_bin)
to sanity check your final results.**


**Hint:** As we did above, first assign the `age_bin` column using the `cut()`
function, then modify the column accordingly with the `mutate()` snippet to
set "present-day" in the `age_bin` for all present-day individuals.


::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
# we first bin samples according to their age:
metadata$age_bin <- cut(metadata$age, breaks = seq(0, 50000, by = 5000), dig.lab = 10)

table(metadata$age_bin)

# then we modify the bins to include "present-day" labels:
metadata <- metadata %>%
  mutate(
    age_bin = as.character(age_bin),
    age_bin = if_else(is.na(age_bin), "present-day", age_bin)
  )
```


We can check the binning result to see that we've been successful!

```{r}
table(metadata$age_bin)
```


## Exercise 5: Merging metadata

After filtering and clean up, we often need to annotate our popgen data with
some metadata information. What does this mean? Consider the IBD data in its
current state:

```{r}
head(ibd)
```

When we analyze things down the line, we might want to look at IBD patterns
over space and time, look at some temporal changes, etc. However, our IBD
data has none of the information in it, so even if we were to do run our
friends `group_by()` and `summarize()` to get some summary statistics, we
have no idea to correlate them to other variables. We only have names of
individuals, and that's not enough.

The annotation that we need is in the metadata table:

```{r}
head(metadata)
```

**What we need to do is join our IBD data with a selection of the most
important variables in our metadata, which is what we're going to do now.**

```{r}
metadata1 <- metadata
metadata2 <- metadata
```

```{r}
colnames(metadata1) <- paste0(colnames(metadata1), "1")
colnames(metadata2) <- paste0(colnames(metadata2), "2")
```


:::

```{r}
ibd <- inner_join(ibd, metadata1)
ibd <- inner_join(ibd, metadata2)
```

---

The `paste()` function (and also `paste0()`) are very useful whenver we
need to join the elements of two (or more) character vectors together.
The difference between then is that `paste0()` doesn't add a space between
the individual values and `paste()` does (the latter also allows you to
customize the string which should be used for joining instead of the space).
For instance, consider these two vectors and the result of joining them together:

```{r}
v1 <- c("Denmark", "Czech Republic", "Estonia")
v2 <- c("Finland", "Italy", "Estonia")

paste(v1, v2, sep = "-")
```

**Use the same principle to add a new column to your `ibd` table named `pair`,
which will contain a vector of values created by joining of the columns
`country1` and `country2`. Add this column `.after` the `sample1` and `sample2`
and `.before` the `chrom` columns for clearer visibility.
Save the result back to the `ibd` variable.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd <- mutate(ibd, pair = paste(country1, country2, sep = "-"), .before = chrom)
ibd
```

:::

---


## Exercise 6: Reproducibility intermezzo

You have written a lot of code in this chapter, both for filtering and processing
of the IBD data and the metadata. Your script is already very long. If you need
to ever update or change something (which you always will during a project,
usually many times over) it can be hard to figure out which line of your script
should be modified. If you forget to update something somewhere in a long script,
you're in big trouble (and sometimes you won't even find out where's the problem
until its too late).

Our session on reproducibility is in the following chapter, but let's work
towards making your current workflow more reproducible even now.

**Create a new script called `ibd_utils.R` in your RStudio and create the following
functions. Then take bits and pieces from the exercises used above and add
then to the bodies of these functions accordingly.**

1. function `process_ibd()` which will (without accepting any arguments):

- download the IBD data from the internet like you did above,
- process it in the same way you did above,
- return the processed `tibble` object with IBD segments

2. function `process_metadata()`, which will (without accepting any arguments):

- download the metadata from the internet like you did above,
- process and filter it in the same way like above (replacing `NA` in
`age` column, filtering out unwanted individuals, adding the `age_bin`
column, etc.)
- return the processed `tibble` object with metadata

3. function `join_metadata()`, which will accept arguments `ibd` and `metadata`
(produced by the two functions above) and then:

- join the `ibd` table with the `metadata` table
- add the `pair` column with `country1-country2` information
- return the finalized `tibble` with all information

**Do not write all the code at once! Start with the first function, test
it by executing it in your R console, and check that your results make sense
before you move on to the other function. Building up more complex pipelines
from simple components is absolutely critical to minimize bugs!**

**After you're done with this exercise, you should create a new script
(you can name it something like `ibd_analysis.R`) and be able to add the
following code:**

```{r}
#| eval: false
source("ibd_utils.R")

ibd <- process_ibd()
metadata <- process_metadata()

ibd <- join_metadata(ibd, metadata)
```

```{r}
#| echo: false
source(here::here("files/repro/ibd_utils.R"))

ibd <- process_ibd()
metadata <- process_metadata()

ibd <- join_metadata(ibd, metadata)
```


**Hint:** If this looks overwhelming and scary, then remember that function
is a block of code (optionally accepting arguments) which simply wraps in
`{` and `}` the code already written by you above, and calls `return` on
the result.

**Hint:** An extremely useful shortcut when writing R functions is "Run
function definition" under `Code` `->` `Run region`. Remember that keyboard
shortcut! (On macOS it's `Option+CMD+F`).




## Exercise 7: Investigating IBD data

**Can you use the IBD data to figure out which (if any) pairs of samples
are either resulting from duplicates or from first degree relatives? In other
words, whether some samples might, in reality, be the same person, or share
an IBD spanning an entire chromosome 1?**

```{r}
total_ibd <-
  ibd %>%
  group_by(sample1, sample2) %>%
  summarise(total = sum(length)) %>%
  arrange(desc(total))
```

<!-- ```{r} -->
<!-- rel1 <- filter(metadata, grepl("1d_rel_", flag)) %>% print(n=Inf) %>% .$sampleId -->
<!-- rel2 <- filter(metadata, sampleId %in% rel1)$flag %>% gsub("1d_rel_", "", .) %>% gsub(";.*", "", .) -->
<!-- rels_df <- tibble(sample1 = c(rel1, rel2), sample2 = c(rel2, rel1)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- right_join(total_ibd, rels_df) %>% print(n=Inf) -->
<!-- ``` -->


<!-- 44 VK110      VK230       85.9 -->
<!-- 45 Vt779      Vt808       57.3 -->
<!-- 46 RISE487    RISE489     50.1 -->
<!-- 47 RISE486    RISE489     45.8 -->






**Generally speaking, very short IBD segments are not very trustworthy.
Filter only to those segments which are longer than 1 Mb.
Save the result back to the `ibd` variable.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd <- filter(ibd, length > 1)
```



---

**What is the shorted IBD segment? What is the longest? How about mean and median?**

**Note:** Don't forget the `summary()` function!

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
summary(ibd$length)
```


:::

---

**Visualize the histogram of lengths of all IBD segments across your entire
data set.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ggplot(ibd, aes(length)) + geom_histogram()
```


:::


**Let's start simple and ignore the temporal dimension of IBD sharing for now,
and focus only on present-day individuals. To do this, `filter()` only for IBD
segments shared by two present-day individuals (i.e., individuals with `age1`
or `age2` equal to 0). Similarly, `filter()` only on individuals from the
following geographic regions, also based on the additional metadata `country1`
and `country2` added to your IBD table earlier. Save your filtered IBD
table to a variable `ibd_eur`.**

```{r}
europe <- c("SouthernEurope", "WesternEurope", "NorthernEurope", "CentralEasternEurope")
```


::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd_eur <- filter(
  ibd,
  age1 == 0 & age2 == 0 &
  region1 %in% europe & region2 %in% europe
)
```

:::


```{r}
ibd_eur %>%
ggplot() +
  geom_jitter(aes(length, pair))
```

```{r}
summary_df <-
  ibd_eur %>%
  group_by(pair) %>%
  summarize(mean_length = mean(length), total_length = sum(length))
```

```{r}
summary_df %>%
  ggplot() +
  geom_point(aes(mean_length, pair))
```

```{r}
library(forcats)

ibd_eur %>%
  group_by(pair) %>%
  summarize(mean_length = mean(length)) %>%
  ggplot() +
  geom_point(aes(mean_length, fct_reorder(pair, mean_length)))
```

```{r}
summary_df <-
  ibd_eur %>%
  group_by(pair) %>%
  summarize(mean_length = mean(length), total_length = sum(length)) %>%
  pivot_longer(
    cols = c(mean_length, total_length),
    names_to = "statistic",
    values_to = "value"
  )
```

```{r}
ggplot(summary_df) +
  geom_point(aes(value, pair)) +
  facet_wrap(~ statistic)
```

```{r}
ggplot(summary_df) +
  geom_point(aes(value, fct_reorder(pair, value))) +
  facet_wrap(~ statistic, scales = "free_x")
```

```{r}
library(tidytext)

ggplot(summary_df) +
  geom_point(aes(value, reorder_within(pair, value, within = statistic))) +
  facet_wrap(~ statistic, scales = "free")
```

```{r}
p_mean <-
  filter(summary_df, statistic == "mean_length") %>%
  ggplot +
  geom_point(aes(value, fct_reorder(pair, value))) +
  facet_wrap(~ statistic, scales = "free_x")

p_mean
```


```{r}
p_sum <-
  filter(summary_df, statistic == "total_length") %>%
  ggplot +
  geom_point(aes(value, fct_reorder(pair, value))) +
  facet_wrap(~ statistic, scales = "free_x")

p_sum
```

```{r}
library(cowplot)

plot_grid(p_mean, p_sum)
```



## Further practice

I'm sure you have done some form of table munging and data visualization in your
projects. If you're done with the exercises above, here are some ideas for you:

1. If you haven't used R for processing of tabular data in your work -- maybe
you have done similar table munging in Excel or Google Sheets in a manual
(i.e., non-reproducible) way? -- write your processing steps as a self-contained
R script:

- If you used Excel, you can use the R package [_readxl_](https://readxl.tidyverse.org),
- If you used Google Sheets, you can use the R package [_googlesheets4_](https://googlesheets4.tidyverse.org)

2. If you used Excel or base R for plotting figures, use what you learned
about _ggplot2_ to make beautiful, publication-ready plots as we did in our
exercises.

Yes, this will put you in an uncharted territory. This is scary and totally
normal when doing research. I'm happy to help you out with questions
and issues!