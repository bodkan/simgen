# Visualization and advanced concepts

In this chapter, we will be delving into the data visualization R package
called [_ggplot2_](https://ggplot2.tidyverse.org), which is possibly the
most famous piece of the _tidyverse_ ecosystem. So much so that people who
otherwise don't use any _tidyverse_ functions (or even who don't even use
R for data analysis itself) still use _ggplot2_ for making figures. It really
is that good.

**Here is how the start of our solutions script for the day will look like.**
Note the addition of `library(ggplot2)` to the list of R packages used in
the previous chapter. Although you could use _ggplot2_ without the rest,
it ties so neatly with every other part of the _tidyverse_ ecosystem that you
almost always end up using them together.

```{r}
#| message: false
library(ggplot2) # the star of the day!

library(dplyr)
library(tidyr)
library(readr)
```

**Let us also read in data which we will be using in these exercises.** These
are coordinates of identity-by-descent (IBD) segments between pairs of
individuals in a
[huge aDNA study](https://www.nature.com/articles/s41586-023-06865-0)
we've already talked about. This data is huge and quite complex -- I've
prefiltered it to contain only IBD segments for chromosome 1.

::: {.aside}
Why use IBD for these exercises? First, IBD data are increasingly
popular across population genomics and evolutionary biology, so it's very likely
you will encounter it in your own work. Second, it's an excellent data se on
which you can practice and develop your data science skills.
:::

```{r}
ibd_segments <- read_tsv("https://tinyurl.com/simgen-ibd-segments")
```

And **we also need to read the corresponding metadata, with which you are already
very closely familiar with**:

```{r}
metadata_all <- read_tsv("https://tinyurl.com/simgen-metadata")
```

**Create a new R script in RStudio, (`File` `->` `New file` `->` `R Script`) and
save it somewhere on your computer as `tidy-viz.R` (`File` -> `Save`). Copy
the two chunks of code above into it and let's get started!**

You just got a new data set from a bioinformatics software, in this case
the IBDseq software for detecting IBD segments between pairs of individuals.
Before you proceed with doing any kind of statistical analysis you need to
do two things:

1. Exploring the data to see _what_ is it that you just got.
2. Filtering and processing it in a way which will make your work easier.

Let's tackle step 1 first.

---

## Exercise 1: Exploring new data

**As a sanity check, do you have metadata information for every individual in
the `sample1` and `sample2` columns of the IBD table? What about the other
way around -- do all individuals in the metadata have some IBD relationship to
another individual? If not, find out which individuals are these.**

This is another sort of sanity checking you will be doing all the time. We can
only analyze data for which we have metadata information (population assignment,
geographical location, dating information), so let's make sure we have what we
need.

**Hint:** Another way to phrase this question is this: does every name that
appears in either `sample1` or `sample2` column of `ibd` have a record in the
`sampleId` column of `metadata` (i.e., is information in one vector of names
a perfect subset of the second vector of names)? Remember that you can use the
function `unique()` to get all unique values in a given vector (as in, all
unique values in vector `ibd$sample1` which has otherwise many duplicated
entries). And remember the existence of `%in%` and `!` operators!

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

We can get unique values across a combination of vectors by first binding
everything together using `c(ibd$sample1, ibd$sample2)` which gets us a single
vector, then calling `unique()` on that:

```{r}
ibd_samples <- unique(c(ibd_segments$sample1, ibd_segments$sample2))

metadata_samples <- metadata_all$sampleId
```

Then we can use our well-known operator `%in%` to check that every sample in
the IBD data has a representative in the metadata:

```{r}
all(ibd_samples %in% metadata_samples)
```

Let's also look at the inverse test:

```{r}
all(metadata_samples %in% ibd_samples)
```

Interesting, some individuals don't have any IBD with anybody else. Who are they?

```{r}
metadata_all[!metadata_samples %in% ibd_samples, ]
```

Why doesn't that ancient Danish person have any IBD with anyone is interesting,
but perhaps not a red flag we should be worrying about in our analyses. Same
goes for the Archaic individuals -- even if they had some IBD shared with
modern humans (which we would expect in principle), perhaps the author of the
IBD data set filtered those IBD segments out.

:::

---

**Which columns does the IBD data have? What's the format of the data?
What ranges or distributions of values do you have available, and with what
data types? Do you have information for the entire genome?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
head(ibd_segments)
```


```{r}
glimpse(ibd_segments)
```

We have information just for chromosome 1 to make the data set a little
smaller and easier for your laptops to handle.

```{r}
table(ibd_segments$chrom)
```

:::


## Exercise 2: IBD processing

**Add a new column using the `mutate()` function called `length`, which contains
the length of each IBD segment in centimorgans (`end - start`). Save the result
back to the variable `ibd_segments`.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd_segments <- ibd_segments %>% mutate(length = end - start)

ibd_segments
```

Note that you don't always use a _tidyverse_ approach. Sometimes doing a simple
thing using a simple method is just... simpler:

```{r}
# we first make a copy of the original data
ibd_segments <- ibd_segments
# and then add the new column
ibd_segments$length <- ibd_segments$end - ibd_segments$start

ibd_segments
```

:::


---

We have processed our IBD table a bit, so let's proceed with the metadata. There's
much more information than we need for now, so let's make the data a bit smaller
and easier to look at at a glance.

**`select()` a subset of the metadata with the following columns and store it in
the same variable `metadata`: `sampleId`, `country`, `continent`, `ageAverage`.
Then `rename()` `sampleId` to `sample`, `popId` to `pop`, and `ageAverage` to
`age` just to save ourselves some typing.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
metadata <- select(metadata_all, sample = sampleId, country, continent, age = ageAverage)

metadata
```

:::

---

**Just as you did in the previous chapter, use `mutate()` and `if_else()` to
make sure that the "Modern" individuals have the `age` set to 0, instead of
`NA` (and everyone else's age stays the same). In other words, replace the
`NA` values of `age` with 0.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
metadata <- mutate(metadata, age = if_else(is.na(age), 0, age))
```

Let's make sure we haven't missed anything else:

```{r}
all(!is.na(metadata$age))
```

:::

---

**Our analyses will exclusively focus on modern humans. Filter out the three
archaics in the `metadata`, saving the results into the same `metadata`
variable again. As a reminder, these are individuals whose `sample` name
is among `c("Vindija33.19", "AltaiNeandertal", "Denisova")` which you can
test in a `filter()` command using the `%in%` operator.**

**Hint:** Remember that you can do not only `column %in% c(... some values...)`
but also do the opposite test as `!column %in% c(... some values...)` (notice
the `!` operator in the second version).

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
metadata <- filter(metadata, !sample %in% c("Vindija33.19", "AltaiNeandertal", "Denisova"))
```

:::

## Exercise 4: Metadata processing

We now have a cleaner IBD table looking like this:

```{r}
head(ibd_segments)
```

And here's our metadata information:

```{r}
head(metadata)
```

Our `set` has only two values, "Modern" and "Ancient". Although useful, we
might want to do some fancier analyses later down the line, looking at IBD
as a time series.

**Let's introduce an incredibly useful function called `cut()`.
Take a look at `?cut` help page and skim through it to figure out what it does.
As a bit of a hint, we will want to add a new metadata column which will indicate
in which age bin (maybe, split in steps of 5000 years) do our individuals
belong to.**

Here's a small example to help us get started. Think about what
the `cut()` function does here based on the result it gives you.
You can pretend for now that the `ages` variable corresponds to age of our
samples in the huge `metadata` table:

```{r}
# a toy example data frame mimicking the age column in our huge metadata table
df <- data.frame(age = c(0, 0, 1000, 0, 5000, 10000, 7000, 13000, 18000, 21000, 27000, 30000))

# let's first generate the breakpoints for our bins (check out `?seq` if
# you're confused by this!)
breakpoints <- seq(0, 50000, by = 5000)
breakpoints

# binning the age into groups using our breakpoints
df$age_bin <- cut(df$age, breaks = breakpoints)

df
```

**Note:** The function `cut()` is extremely useful whenever you want to discretize
some continuous variable in bins (basically, a little similar to what
a histogram does in context of plotting). Doing statistics on this kind of
binned data is something we do very often. So never forget that `cut()` is
there to help you!

---

**In the example of the `cut()` function right above, what is the data type
of the column `age_bin` created by the `cut()` function? Use `glimpse(df)` to see
this data type, then skim through the documentation of `?factor`. Additionally,
why is the `age_bin` value equal to `NA` for some of the values? (We will fix this
later, don't worry.)**

As you're thinking about these questions, consider the two following vectors.
When you print them out in your R console (by typing `x1` and `x2`) you will
get something that looks almost identical. **What happens when you apply the
`typeof()` function on both of them? `x2` gives you a strange result -- why?
What do you get when you run the following command `levels(x2)`? What do you
get when you run `as.character(x2)`?

```{r}
x1 <- c("hello", "hello", "these", "are", "characters/strings")
x2 <- factor(x1)

x1
x2
```

**Note:** The discussion of "factors" should've been technically part of our
R bootcamp chapter, on the topic of "data types". However, that section was
already too technical, so I decided to move it here to the data analysis section,
because I think it makes more sense to explain it in a wider context.

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

The reason you get the `typeof(x1)` as "character" but `typeof(x2)` as "integer"
although both are "basically strings" is because factors are a special data
type for encoding categorical variables which can only have a set of fixed
possible values. Internally, for efficiency, levels of a factor variables
are stored as integers, and their values or just "labels" for those integers.

Importantly, factor levels are actually, which is very useful for plotting,
as we will see later.

For now, don't worry about this too much. We needed to introduce the concept
of factors because they are very frequently used whenever we need to bin
continuous data, like we will now for assigning samples into bins based
on their `age` value.

Oh, and the answer to why `cut()` gave us the `NA` for every 0 value is
because of its `include.lowest` argument is set to `FALSE`. Compare these two:

```{r}
cut(df$age, breaks = seq(0, 50000, by = 10000))
```

```{r}
cut(df$age, breaks = seq(0, 50000, by = 10000), include.lowest = TRUE)
```

However, this isn't what we want, because we want to treat present-day individuals
separately as their own category, not include them with other ancient people
less than 5000 years old.

The `levels()` function is useful for getting the "labels" of the categories
as they are presented to you in various outputs (rather than their internal
numerical encoding).

Consider the original vector `x2` (note the duplicated "hello" value):

```{r}
x2
```

And the `levels()` output:

```{r}
levels(x2)
```

When we run `as.character()`, we effectively convert the (categorical) factor
values into normal strings (i.e., basically convert those values into their
plain labels). This is very useful whenever we want to manipulate factors,
as we'll se below:

```{r}
as.character(x2)
```

:::

---

**The scientific notation format of bin labels with all those `+` is very
annoying to look at. How can you use the `dig.lab =` argument of the `cut()`
functions to make this prettier? Experiment in the R console to figure this out,
then modify the `df$age_bin <- cut(df$age, breaks = breakpoints)` command
in your script accordingly.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Let's experiment first:

```{r}
cut(df$age, breaks = breakpoints)
cut(df$age, breaks = breakpoints, dig.lab = 3)
cut(df$age, breaks = breakpoints, dig.lab = 10)
```

Our solution to get rid of the ugly scientific notation in our labels:

```{r}
df$age_bin <- cut(df$age, breaks = breakpoints, dig.lab = 10)

df
```

Much nicer to look at!

:::



---

You have now learned that `cut()` has an optional argument called
`include.lowest =`, which includes the lowest value of 0 (representing
the "present-day" age of our samples) in the lowest bin [0, 5]. However, in the
case of our assignment of samples from present-day, this is not what we want.
We want present-day individuals to have their own category called "present-day".

Here's a useful bit of code I use often for this exact purpose. If we start
from the original toy example data frame (with the `NA` values assigned to
present-day ages of 0):

```{r}
df
```

We can fix this by the following three-step process, described in the comments:

```{r}
bin_levels <- levels(df$age_bin) # 1. extract labels (no "present-day" category yet)

df <-
  df %>%
  mutate(
    age_bin = as.character(age_bin),                      # 2. convert factors into strings
    age_bin = if_else(is.na(age_bin), "present-day", age_bin) # 3. replace NA with "present-day"
  )
```

When we print the modified `df` table, we see all bins properly assigned now,
including the present-day samples with ages at 0:

```{r}
df
```

**This is a very useful pattern which you will get to practice now on the full
`metadata` table.**

---

**Now that you're familiar with `cut()`, use the functions `mutate()` and
`cut()` again to create a new column `age_bin` this time on the whole `metadata`
table. The new column should carry a category age of each individual in steps of
2000 years again. Use the example from above to do this. Use `table(metadata$age_bin)
to sanity check your final results.**


**Hint:** As we did above, first assign the `age_bin` column using the `cut()`
function, then modify the column accordingly with the `mutate()` snippet to
set "present-day" in the `age_bin` for all present-day individuals.


::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
# we first bin samples according to their age:
metadata$age_bin <- cut(metadata$age, breaks = seq(0, 50000, by = 10000), dig.lab = 10)

table(metadata$age_bin)

# then we modify the bins to include "present-day" labels:
metadata <- metadata %>%
  mutate(
    age_bin = as.character(age_bin),
    age_bin = if_else(is.na(age_bin), "present-day", age_bin)
  )
```


We can check the binning result to see that we've been successful!

```{r}
table(metadata$age_bin)
```


## Exercise 5: Merging metadata

After filtering and clean up, we often need to annotate our popgen data with
some metadata information. What does this mean? Consider the IBD data in its
current state:

```{r}
head(ibd_segments)
```

When we analyze things down the line, we might want to look at IBD patterns
over space and time, look at some temporal changes, etc. However, our IBD
data has none of the information in it, so even if we were to do run our
friends `group_by()` and `summarize()` to get some summary statistics, we
have no idea to correlate them to other variables. We only have names of
individuals, and that's not enough.

The annotation that we need is in the metadata table:

```{r}
head(metadata)
```

**What we need to do is join our IBD data with a selection of the most
important variables in our metadata, which is what we're going to do now.**

```{r}
metadata1 <- metadata
metadata2 <- metadata
```

```{r}
colnames(metadata1) <- paste0(colnames(metadata1), "1")
colnames(metadata2) <- paste0(colnames(metadata2), "2")
```


:::

```{r}
ibd_segments <- inner_join(ibd_segments, metadata1)
ibd_segments <- inner_join(ibd_segments, metadata2)

ibd_segments
```

---

The `paste()` function (and also `paste0()`) are very useful whenver we
need to join the elements of two (or more) character vectors together.
The difference between then is that `paste0()` doesn't add a space between
the individual values and `paste()` does (the latter also allows you to
customize the string which should be used for joining instead of the space).
For instance, consider these two vectors and the result of joining them together:

```{r}
v1 <- c("Denmark", "Czech Republic", "Estonia")
v2 <- c("Finland", "Italy", "Estonia")

paste(v1, v2, sep = ":")
```

**Use the same principle to add a new column to your `ibd` table named `country_pair`,
which will contain a vector of values created by joining of the columns
`country1` and `country2`. Add this column `.after` the `sample1` and `sample2`
and `.before` the `chrom` columns for clearer visibility. Do the same to create
a `region`_pair` based on `continent1` and `continent2`.
Save the result back to the `ibd` variable.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd_segments <- mutate(
  ibd_segments,
  country_pair = paste(country1, country2, sep = ":"),
  region_pair = paste(continent1, continent2, sep = ":"),
  .before = chrom
)

ibd_segments
```

:::

---


**In addition to computing statistics across pairs of geographical regions,
we will also probably want to look at temporal patterns. Create a new column
`time_pair`, which will in this case contains a `paste()` combination
of `age_bin1` and `age_bin2`, added `.after` the `region`_pair` column.
Save the result back to the `ibd` variable.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd_segments <- mutate(ibd_segments, time_pair = paste(age_bin1, age_bin2, sep = ":"), .after = region_pair)

ibd_segments
```

:::


## Exercise 6: Reproducibility intermezzo

You have written a lot of code in this chapter, both for filtering and processing
of the IBD data and the metadata. Your script is already very long. If you need
to ever update or change something (which you always will during a project,
usually many times over) it can be hard to figure out which line of your script
should be modified. If you forget to update something somewhere in a long script,
you're in big trouble (and sometimes you won't even find out where's the problem
until its too late).

Our session on reproducibility is in the following chapter, but let's work
towards making your current workflow more reproducible even now.

---

**Create a new script called `ibd_utils.R` in your RStudio and create the following
functions. Then take bits and pieces from the exercises used above and add
then to the bodies of these functions accordingly.**

1. function `process_ibd()` which will (without accepting any arguments):

- download the IBD data from the internet like you did above,
- process it in the same way you did above,
- return the processed `tibble` object with IBD segments

2. function `process_metadata()`, which will (without accepting any arguments):

- download the metadata from the internet like you did above,
- process and filter it in the same way like above (replacing `NA` in
`age` column, filtering out unwanted individuals, adding the `age_bin`
column, etc.)
- return the processed `tibble` object with metadata

3. function `join_metadata()`, which will accept arguments `ibd` and `metadata`
(produced by the two functions above) and then:

- join the `ibd` table with the `metadata` table
- add the `geo_pair` column with `country1-country2` information
- return the finalized `tibble` with all information

**Do not write all the code at once! Start with the first function, test
it by executing it in your R console, and check that your results make sense
before you move on to the other function. Building up more complex pipelines
from simple components is absolutely critical to minimize bugs!**

**Make sure to add comments to your code! Reproducibility is only half of
the story -- you (and other people) need to be able to understand your code
a long time after you wrote it.**

**After you're done with this exercise, you should create a new script
(you can name it something like `ibd_analysis.R`) and be able to add the
following code.**

**Note:** The `source()` command executes all the code in your
utility script and therefore makes your custom-built functions available
in your R session. This is an incredibly useful trick which you should use
all the time whenever you modularize your code into reproducible functions
in their own scripts.

```{r}
#| eval: false
source("ibd_utils.R")

metadata <- process_metadata()
ibd_segments <- process_ibd()

ibd_segments <- join_metadata(ibd_segments, metadata)
```

```{r}
#| echo: false
source(here::here("files/repro/ibd_utils.R"))

metadata <- process_metadata()
ibd_segments <- process_ibd()

ibd_segments <- join_metadata(ibd_segments, metadata)
```


**Hint:** If this looks overwhelming and scary, then remember that function
is a block of code (optionally accepting arguments) which simply wraps in
`{` and `}` the code already written by you above, and calls `return` on
the result.

**Hint:** An extremely useful shortcut when writing R functions is "Run
function definition" under `Code` `->` `Run region`. Remember that keyboard
shortcut! (On macOS it's `Option+CMD+F`).

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

You can find my solution
[here](https://github.com/bodkan/simgen/blob/main/files/repro/ibd_utils.R).

:::

**It's worth pausing here and reflecting on what we've just done. Yes,
we took (lots!) of code already written and basically "just moved it elsewhere".
But consider how clean your new script `ibd_analysis.R` is and how easily
readable it is. What we've done is sometimes called "abstraction" in software
engineering. We took components of our pipeline, and "hidden" them away so
that we no longer have to think in terms of `select()`, `filter()`, `group_by()`,
etc. We now can think about steps called `process_ibd()`, `process_metadata()`,
and `join_metadata()`. Much less code to look at and think about! Plus,
if we do need to take a deep dive into details, we just have to look at the
code of our functions!**

---

**Point your cursor somewhere inside the `process_ibd()` call in your
new script `ibd_analysis.R` and press "CTRL+.". This is how easy it is
to navigate code, even when we modularized it!

---

Having your processing and filtering code available in a self-contained
modularized way will make a huge difference in later parts of our workshop.


## Exercise 6: Data visualization with _ggplot2_

An important, powerful, and even elegant concept with building visualizations
using _ggplot2_ is the idea of _layering_.

### Distribution of a categorical variable

Let's start very simply, and introduce the layering aspect of _ggplot2_
visualization package step by step. **Our data frame has a column `age_bin`,
which contains the assignment of each individual into a respective time
period. Let's start by visualizing the count of individuals in each time bin.**

#### `geom_bar()`

```{r}
ggplot(metadata)
```

```{r}
ggplot(metadata, aes(x = age_bin))
```

```{r}
ggplot(metadata, aes(x = age_bin)) + geom_bar()
```

**Let's add more layers! Use a `xlab()` function to add an x-axis label
element using the `+` operator.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Just as we did with _tidyverse_ `%>%` data transformation pipelines, as a
_ggplot2_ visualization pipeline gets more complex, it's a good idea to
introduce indentation so that each visualization steps is on its own line.

```{r}
ggplot(metadata, aes(x = age_bin)) +
  geom_bar() +
  xlab("Time period [years before present]")
```

:::

---

**Now continue adding y-axis label with the `ylab()` function.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ggplot(metadata, aes(x = age_bin)) +
  geom_bar() +
  xlab("Time period [years before present]") +
  ylab("Number of individuals")
```

:::

---

**Give your figure a proper main title using the function `ggtitle()`.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ggplot(metadata, aes(x = age_bin)) +
  geom_bar() +
  xlab("Time period [years before present]") +
  ylab("Number of individuals") +
  ggtitle("Distribution of sample counts in each time period")
```

:::

---

**Although individual functions `xlab()`, `ylab()`, `ggtitle()` are useful,
oftentimes it's better to use a general function `labs()`. Look up its
documentation under `?lab`, then rewrite the code for your figure to use
only this function, replacing your uses of `xlab()`, `ylab()`, and `ggtitle()`
just with `labs()`. Note that the function has other useful arguments -- go
ahead and use as many of them as you want.**

**Note:** Don't worry about making your figure cluttered, this is just for
practice. In a real paper, you wouldn't use title or caption directly in a
_ggplot2_ figure, but it's definitely useful for work-in-progress reports at
meetings, etc.

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ggplot(metadata, aes(x = age_bin)) +
  geom_bar() +
  labs(
    y = "Number of individuals",
    x = "Time period [years before present]",
    title = "Distribution of sample counts in each time period",
    subtitle = "Counts for individuals in 1000 Genomes Project and MesoNeo data",
    caption = "Here is an optional caption for the figure, similarly to what
      you might do in a real scientific article as a more detailed description of
      of what is going on in the plot."
  )
```

:::

---

**You can see that the "present-day" bin completely overwhelms the number of
individuals in the oldest bins. This often happens with data which follow
a more or less exponential scale. A useful trick is adding a `+ scale_y_log()`
layer. You can probably guess what it does, so try adding it to your code!**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Of course, this function transforms the y-axis on the logarithmic scale! Very
useful!

```{r}
ggplot(metadata, aes(x = age_bin)) +
  geom_bar() +
  labs(
    y = "Number of individuals",
    x = "Time period [years before present]",
    title = "Distribution of sample counts in each time period",
    subtitle = "Counts for individuals in 1000 Genomes Project and MesoNeo data",
    caption = "Here is an optional caption for the figure, similarly to what
      you might do in a real scientific article as a more detailed description of
      of what is going on in the plot."
  ) +
  scale_y_log10()
```

:::

---

**Does the order of adding layers with the `+` operator matter? Do a little
experiment to figure it out!**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

No, generally, it doesn't. This is another very useful feature of _ggplot2_.
Remember that a huge important part of an R data science workflow is interactive
communication with an R console. You can start with a little bit of code
which produces a basic outline of your figure and continue adding useful bits
and pieces to it, modifying the outcome as you go. Almost like an artist!

:::

---

It's useful to keep in mind that you can always pipe a data frame
into a `ggplot()` function using the `%>%` operator, which always places that
table as the first argument in the `ggplot()` call, where the function
expects it. I.e., instead of writing `ggplot(metadata, aes(...))`, you can also
do `metadata %>% ggplot(aes(...))`. This allows you to transform or summarize
data before plotting, which makes the combination of _tidyverse_ and _ggplot2_
infinitely stronger.

**As a refresher and for a bit more practice, `filter()` the metadata first
for individuals who are 10000 years or older, discarding the rest. Then pipe
this `filter()` result into your `ggplot()` code, keeping the plotting part
exactly the same.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
metadata %>%
filter(age > 10000) %>%
ggplot(aes(x = age_bin)) +
  geom_bar() +
  labs(
    y = "Number of individuals",
    x = "Time period [years before present]",
    title = "Distribution of sample counts in each time period",
    subtitle = "Counts for individuals in 1000 Genomes Project and MesoNeo data",
    caption = "Here is an optional caption for the figure, similarly to what
      you might do in a real scientific article as a more detailed description of
      of what is going on in the plot."
  )
```

:::

Believe it or not, with this basic structure of _ggplot2_ visualization and
combining this with any other type of _tidyverse_ manipulation, filtering, and
(as we'll later see), summarization, you're ready to make any figure imaginable.
Let's take this one step further.

---

### Distribution of a numerical variable

In the previous exercise you visualized a distribution of a categorical
variable, specifically the counts of samples in an age category.
Now let's look at continuous variables and this time consider our `ibd`
table if IBD segments between pairs of individuals:

```{r}
tail(ibd_segments)
```

The most interesting quantity we might want to analyse in the IBD context
is the `length` of IBD segments, which can indicate the degree of genetic
affinity or relatedness between individuals. So let's take a look at the 
distribution of IBD lengths across our data set as an opportunity to introduce
new functionality and useful tricks of _ggplot2_.

#### `geom_histogram()` and `geom_density()`

You can visualize a distribution of values using the functions `geom_histogram()`
and `geom_density()`. Both are useful for similar things, each has its strengths
and weaknesses from a visualization perspective.

**Visualize the distribution of `length` values across all individuals in your
IBD data set, starting with the basic simple patterns of:**

1. `ggplot() + geom_histogram()`, or
2. `ggplot() + geom_density()`,

**just like you did in the previous `geom_bar()` example. Of course, you have to
fill in the `aes()` accordingly. Try to use the knowledge you obtained in the
previous exercise! As a reminder, the `length` is expressed in units of
centimorgans, so add immediately an x-axis label clarifying the units to
anyone looking at your figure, either using `xlab()` or `labs(x = ...)`.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Here's a histogram:

```{r}
ibd_segments %>%
  ggplot(aes(length)) +
  geom_histogram() +
  labs(x = "IBD length [centimorgans]")
```

Here's a density plot:

```{r}
ibd_segments %>%
  ggplot(aes(length)) +
  geom_density() +
  labs(x = "IBD length [centimorgans]")
```

:::

---

**To make our data exploration a little easier at the beginning, let's create
a new variable `ibd_eur` from the total `ibd` data, with the following
transformations:**

1. `filter()` for `region_pair == "Europe:Europe"`
2. `filter()` for `time_pair == "present-day:present-day"`

**Save the result of both filtering steps as `ibd_eur`, and feel free to use
the `%>%` pipeline concept that you learned about previously.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

This should be easy for you now as budding _tidyverse_ data munging experts!

```{r}
ibd_eur <-
  ibd_segments %>%
  filter(region_pair == "Europe:Europe") %>%
  filter(time_pair == "present-day:present-day")

ibd_eur
```

---

**Now visualize the distribution of lengths in the reduced, Europe-only
IBD data set stored in the `ibd_eur` variable. Do this in two versions again,
using `geom_histogram()` or `geom_density()`. Additionally, for each of the
two functions specify either `fill` or `color` (or both of them!) based on the
variable `country_pair`. Experiment with the looks of the result and find
your favourite (prettiest, cleanest, easiest to interpret, etc.).**

**How do you compare these different approaches? When does one seems more
appropriate than other?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

1. Histogram version with `fill` set (I personally don't find the `color`
version of histograms useful at all so I'm not showing it here):

```{r}
ibd_eur %>%
  ggplot(aes(length, fill = country_pair)) +
  geom_histogram() +
  labs(x = "IBD segment length [centimorgans]")
```

2. Density versions:

- using `color` only:

```{r}
ibd_eur %>%
  ggplot(aes(length, color = country_pair)) +
  geom_density() +
  labs(x = "IBD segment length [centimorgans]")
```

- using `fill`, which also requires setting the `alpha` transparency to avoid
accidentally hiding some peaks:

```{r}
ibd_eur %>%
  ggplot(aes(length, fill = country_pair, color = country_pair)) +
  geom_density(alpha = 0.5) +
  labs(x = "IBD segment length [centimorgans]")
```

:::

---

We clearly have some individual pairs which share a huge amount of IBD.
We'll quantify how much a bit later, but for now, the x-axis appears in the
density plot is too spread out. This happens often in visualizing numerical
variables. **Use these two additional layers to improve the readability of
your figures by restricting the range of the x-axis of your figures:**

1. Add this layer `+ xlim(0, 10)` to your figure,
2. or this layer `+ coord_cartesian(xlim = c(0, 10))`.

**What's the difference between both possibilities?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Here are the two versions of restricting the x-axis scale. Note that they
differ only by the command used at the 5th line!

1. `coord_cartesian()` performs so-called "soft clipping" -- it restricts the
"viewpoint" on the entire data set:

```{r}
#| code-line-numbers: true
ibd_eur %>%
  ggplot(aes(length, color = country_pair)) +
  geom_density() +
  labs(x = "IBD segment length [centimorgans]") +
  coord_cartesian(xlim = c(0, 10))
```

2. `xlim()` does "hard clipping" -- it effectively removes the points outside
of the given range. This usually isn't what we want, so I personally rarely
if ever use this:

```{r}
#| code-line-numbers: true
ibd_eur %>%
  ggplot(aes(length, color = country_pair)) +
  geom_density() +
  labs(x = "IBD segment length [centimorgans]") +
  xlim(0, 10)
```

Admittedly they both give the same result, but that's not always the case, so
be careful!

:::

### Relationship between two variables

#### `geom_point()`

We'll now look at creating another type of visualization which is extremely
useful and very common: a [scatter plot](https://en.wikipedia.org/wiki/Scatter_plot)!

But first, let's do some more data summarization so that we can demonstrate
building of scatter plots using _ggplot2_. At this point, this should all be
a piece of cake for you!

The previous figures showed distributions of individual segment lengths
on present-day individuals only. Another useful quantity is the number of
segments shared between a pair of individuals and the total number of IBD
sequence between those pairs.

**Practice your knowledge of `group_by()` and `summarize()` and apply them
to our huge `ibd_segments` table, to achieve the following:**

0. Start with our original big IBD table `ibd_segments` (not the smaller `ibd_eur`!)

1. `filter()` for rows in which `region_pair == "Europe:Europe"` (only pairs
within Europe, just as we did before),

2. `filter()` for rows in which `length > 10` (only long IBD segments)

3. `filter()` for rows in which `age_bin1 == age_bin2` (only individuals from
the same age bin),

4. `group_by()` to create groupings based on `sample1`, `sample2`,
`country_pair`, and `time_pair`,

5. `summarize()` to create two new quantities `n_ibd = n()` and `total_ibd = sum(length)` (total number of long IBD segments and their total sequence for each
of individuals).

**Save the result of your `%>%` pipeline implementing the steps 1.-3. above in
a variable `ibd_sum`.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Again, once you know the functions `filter()`, `group_by()`, and `summarize()`,
implementing the pipeline is just a matter of sequencing them together as if
you were building a LEGO set!

```{r}
ibd_long <-
  ibd_segments %>%
  filter(length > 10 & age_bin1 == age_bin2) %>% 
  group_by(sample1, sample2, rel) %>%
  summarize(n_ibd = n(), total_ibd = sum(length))

ibd_long
```

I hope you're all appreciating the awesome data science powers you've already
learned to do this! This would require a crazy amount of work with standard
base R and might be very hard (or downright impossible) to do with Excel.

:::

---

**Your work so far has been based on a small subset of the overall IBD
data, just for chromosome `r unique(ibd_segments$chrom)`. To move to more complex
and interesting visualization, execute this command which reads the `ibd_long`
just like you created it yourself, except based on all chromosomes in the
entire genome. We'll be working on that from now on.**

```{r}
ibd_long <- read_tsv("https://tinyurl.com/simgen-ibd-long", show_col_types = FALSE)
```


---

With our summarized table `ibd_sum` ready, we're ready to create our
scatter plot. When we worked with `geom_histogram()`, `geom_density()`, and
`geom_bar()`, we only needed to do something like this:

```{r}
#| eval: false
df %>%
  ggplot(aes(x = COLUMN_NAME)) +
  geom_FUNCTION()
```

Because scatter plot is two-dimensional, we have to specify
not only the `x` but also the `y` in the `aes()` aesthetic mapping... and with
that bit of information, I think you already know how to do this based
on your knowledge of basic _ggplot2_ techniques introduced above!

**Use the function `geom_point()` to visualize the scatter plot of
`x = total_ibd` against `y = n_ibd`. We know that related individuals share
a large amounts of IBD sequence between each other. As a reminder, the entire
human genome spans about 3000 centimorgans. Can you guess from your figure
which pairs of individuals (a point on your figure representing one such pair)
could be potentially closely related?**

**Note:** Don't worry about this too much, just take a guess. Below we'll look
at this question more closely.

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

It looks like some pairs of individuals share almost their entire genome in
IBD, around the whole 3 gigabases of sequence!

We'll work on clarifying that below.

```{r}
ibd_sum %>%
  ggplot(aes(x = total_ibd, y = n_ibd)) +
  geom_point()
```

:::

---

**From the introduction of histograms and densities, you're already familiar
with modifying the `aes()` aesthetic of a geom layer using the `color`
argument of `aes()`. Right now your dots are all black, which isn't super
informative. Luckily, you're IBD table has a "mysterious" column called
`rel`. What happens when you `color` points based on the values in this
column?**

**Look at a figure from [this huge](https://www.nature.com/articles/s41588-023-01582-w/figures/3)
study of IBD patterns and their relationship to the degree of relatedness
between individuals? This is completely independent data set and independent
analysis, but do you see similarities between this paper and your figure?**

**Use the `+ labs()` layer function to properly annotate your axes, and give
your figure a nice title too. Additionally, you can give your legend
a nicer readable title too using the layer function
`+ guides(color = guide_legend("relatedness")`**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd_sum %>%
  ggplot(aes(x = total_ibd, y = n_ibd, color = rel)) +
  geom_point() +
  labs(x = "total IBD sequence", y = "number of IBD segments",
       title = "Total IBD sequence vs number of IBD segments",
       subtitle = "Both quantities computed only on IBD segments 10 cM or longer") +
  guides(color = guide_legend("relatedness"))
```

:::

---

So far we've always followed this pattern of _ggplot2_ usage, to borrow our
very first `geom_histogram()` example:

```{r}
ggplot(ibd_segments, aes(length)) +
  geom_histogram()
```

However, you can also do this and it will give the same result:

```{r}
ggplot() +
  geom_histogram(data = ibd_segments, aes(length))
```

In other words, each `geom_<...>()` function accepts both `data` data frame
and also its own `aes()` aesthetic and mapping function. You could think of
this as each individual geom having a "self-contained" `ggplot()` function's
ability.

This can be very useful whenever we want to plot different aspects of the data
with their own aesthetic parameters (colors, shapes, sizes). Let's work through
an exercise to explain this better, step by step, to make our IBD scatter plot
figure much more nicer to look at.

```{r}
ibd_unrel <- filter(ibd_sum, is.na(rel))
ibd_rel <- filter(ibd_sum, !is.na(rel))

ggplot() +
  geom_point(data = ibd_unrel, aes(x = total_ibd, y = n_ibd), color = "lightgray") +
  geom_point(data = ibd_rel, aes(x = total_ibd, y = n_ibd, color = rel, shape = rel)) +
  labs(x = "total IBD sequence [centimorgan]", y = "number of IBD segments")
```



::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd_sum %>%
  filter(country1 == country2) %>%
  ggplot(aes(y = time_pair, x = total_ibd)) +
  geom_boxplot() +
  theme(legend.position = "none")
```

:::

---

**Sometimes when you deal with numerical variables like those in your
histogram, a couple of outliers can make for a slightly hard-to-read figure.



The distribution of coverage across all individuals is not that informative
because it clumps together very different samples across very different
ages and geographical regions. Maybe we can take a look at those distributions
across different categories?

We clearly have two sets of categories we might be interested in. One is
perhaps the `country` of origin, the other the `age_bin`. **Let's introduce
a new mapping of an aesthetic called `fill`. In your `aes()` call, in
addition to `aes(x = age)`, write `aes(x = age, fill = age_bin)`. What happens
when you do this?**

**Note:** This effectively introduces the possibility of plotting two variables
at once! One is `coverage` (the continuous variable along the x-axis), the
other is `age_bin` (a categorical variable plotted as colors).

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd_eur %>%
  ggplot(aes(total_ibd)) +
  geom_histogram()
```

:::

---

**Staying with this exercise, what's the difference between setting the `fill`
aesthetic with `aes(x = age, fill = age_bin)` and the `color` aesthetic
with `aes(x = age, fill = age_bin)`? What if you do both?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

The `fill` mapping is useful for filling out geometries which involve "areas"
of some kind (like a histogram or a barplot). The `color` mapping is more
useful for outlines alone, like we'll see in a following exercise on plotting
densities. **For now just remember that `fill` and `color` are useful
parameters that you can set for basically every plotting function in _ggplot2_!**

```{r}
metadata %>%
  filter(age > 0) %>%
  ggplot(aes(coverage, fill = age_bin)) +
  geom_histogram()
```

```{r}
metadata %>%
  filter(age > 0) %>%
  ggplot(aes(coverage, color = age_bin)) +
  geom_histogram()
```

:::

---

**There are two ways in which you can adjust the binning of a _ggplot2_
histogram. Check out `?geom_histogram` and experiment a little bit.**

**Note:** The arguments you find which modify the visualization of a
histogram are not mapping, so they don't belong in the `aes()` call, but
either after it (in the `ggplot()` call) or you can put them directly
inside the `geom_histogram(...)` call. _I always get this wrong, so
whenever you have issues with this, take a look where you're specifying
these optional arguments!_

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

1. We have the `bins` argument which changes the number of bins. This sets
the number of histogram bars to a hardcoded value of 100:

```{r}
metadata %>%
  filter(age > 0) %>%
  ggplot(aes(coverage, fill = age_bin)) +
  geom_histogram(bins = 100)
```

2. And we have the `binwidth` argument which changes the width of each bin.
This spaces each bar of the histogram at 1 point of coverage:

```{r}
metadata %>%
  filter(age > 0) %>%
  ggplot(aes(coverage, fill = age_bin)) +
  geom_histogram(binwidth = 1)
```

:::

---

In addition to `bins` and `binwidth`, the function `geom_histogram()` has two
additional arguments:

- `position` has the default value `"stack"`, but can also be set to
`"identity"` or `"dodge"`,
- `alpha`, which can have a value between 0 and 1 (1 being the default).

**What happens when you set `position = "identity"` and `alpha = 0.5`? How
is the result different from the default (which is either `geom_histogram()`
alone or `geom_histogram(position = "stack")`)?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

1. Here is the default which you already know:

```{r}
metadata %>%
  filter(age > 0) %>%
  ggplot(aes(coverage, fill = age_bin)) +
  geom_histogram() # same as geom_histogram(position = "stack")
```

2. Here is the `"dodge"` variant:

```{r}
metadata %>%
  filter(age > 0) %>%
  ggplot(aes(coverage, fill = age_bin)) +
  geom_histogram(position = "dodge")
```

3. And here is the `"identity"` variant. Note that we should probably specify
the `alpha` transparency too!

```{r}
metadata %>%
  filter(age > 0) %>%
  ggplot(aes(coverage, fill = age_bin)) +
  geom_histogram(position = "identity")
```

```{r}
metadata %>%
  filter(age > 0) %>%
  ggplot(aes(coverage, fill = age_bin)) +
  geom_histogram(position = "identity", alpha = 0.6)
```

:::


### Faceting intermezzo

```{r}
metadata %>%
  filter(age > 0) %>%
  ggplot(aes(coverage, fill = age_bin)) +
  geom_histogram() +
  facet_wrap(~ age_bin, scales = "free_y")
```

### Combining figures


### Two numerical variables

```{r}
geo_df <-
  metadata %>%
  filter(age > 0) %>%
  group_by(country) %>%
  summarize(
    count = n(),
    avg_lat = mean(latitude, na.rm = TRUE),
    avg_lon = mean(longitude, na.rm = TRUE),
    avg_cov = mean(coverage, na.rm = TRUE)
  )
```

```{r}
p1 <-
  ggplot(geo_df, aes(x = avg_lat, y = count)) +
  geom_point() +
  coord_cartesian(xlim = c(-90, 90))
```

```{r}
p2 <-
  ggplot(geo_df, aes(x = avg_lon, y = count)) +
  geom_point() +
  coord_cartesian(xlim = c(-90, 90))
```

```{r}
library(cowplot)

plot_grid(p1, p2)
```

```{r}
p1 <- p1 + geom_smooth(method = "lm")
```

```{r}
p2 <- p2 + geom_smooth(method = "lm")
```

```{r}
plot_grid(p1, p2)
```




## Exercise 7: Summarizing IBD data

OK, data munging (widely acknowledged to be the most annoying part of doing
data science) is done. Time to do some data exploration and science!
In this and later exercises you will get to practice your _tidyverse_ skills
from the previous chapter on your new exciting IBD data.

---

```{r}
ibd_today <- filter(ibd, time_pair == "present-day:present-day")
ibd_today
```

---

**Plot the distribution of lengths of IBD segments overall.**

```{r}
ibd_today %>%
  ggplot() +
  geom_density(aes(length))
```

```{r}
ibd_today %>%
  ggplot() +
  geom_density(aes(length)) +
  geom_vline(xintercept = 2) +
  coord_cartesian(xlim = c(0, 10))
```

---

**Use `group_by()` and `summarize()` to compute the total length of IBD sequence
for each pair of `sample1` and `sample2` by summing it up into a new column
`total`. Save the result into a variable `ibd_indiv`. Sort the result based on
this computed `total` using the `arrange()` function.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd_indiv <-
  ibd %>%
  group_by(sample1, sample2) %>%
  summarise(total = sum(length)) %>%
  arrange(desc(total))
```

:::

---

**Although interesting, the previous result only shows the `total` for
each combination of `sample1` and `sample2`, because `group_by()` lost other
metadata (we only told it to group by the sample names). Modify your solution
to the previous exercise by grouping not just based on samples, but also
based on `geo_pair` and `time_pair`. This will allow us to investigate
IBD patterns geographically and temporally.**

**Hint:** Just as you did `group_by(sample1, sample2)` in the previous
solution, add the additional pair columns you want to group over after
`sample1, sample2`.

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd_indiv <-
  ibd %>%
  group_by(sample1, sample2, geo_pair, time_pair) %>%
  summarise(total = sum(length)) %>%
  arrange(desc(total))
```

:::

---
```{r}
rel1 <- filter(metadata, grepl("1d_rel_", flag)) %>% print(n=Inf) %>% .$sampleId
rel2 <- filter(metadata, sampleId %in% rel1)$flag %>% gsub("1d_rel_", "", .) %>% gsub(";.*", "", .)
rels_df <- tibble(sample1 = c(rel1, rel2), sample2 = c(rel2, rel1))
```

```{r}
right_join(total_ibd, rels_df) %>% print(n=Inf)
```


44 VK110      VK230       85.9
45 Vt779      Vt808       57.3
46 RISE487    RISE489     50.1
47 RISE486    RISE489     45.8






Figure out which (if any) pairs of samples are either resulting from
duplicates or from first degree relatives? In other words, whether some samples
might, in reality, be the same person, or share an IBD spanning an entire
chromosome 1?*
**Generally speaking, very short IBD segments are not very trustworthy.
Filter only to those segments which are longer than 1 Mb.
Save the result back to the `ibd` variable.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd <- filter(ibd, length > 1)
```



---

**What is the shorted IBD segment? What is the longest? How about mean and median?**

**Note:** Don't forget the `summary()` function!

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
summary(ibd$length)
```


:::

---

**Visualize the histogram of lengths of all IBD segments across your entire
data set.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ggplot(ibd, aes(length)) + geom_histogram()
```


:::































































---

```{r}

```

































**Let's start simple and ignore the temporal dimension of IBD sharing for now,
and focus only on present-day individuals. To do this, `filter()` only for IBD
segments shared by two present-day individuals (i.e., individuals with `age1`
or `age2` equal to 0). Similarly, `filter()` only on individuals from the
following geographic regions, also based on the additional metadata `country1`
and `country2` added to your IBD table earlier. Save your filtered IBD
table to a variable `ibd_eur`.**

```{r}
europe <- c("SouthernEurope", "WesternEurope", "NorthernEurope", "CentralEasternEurope")
```


::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
ibd_eur <- filter(
  ibd,
  age1 == 0 & age2 == 0 &
  region1 %in% europe & region2 %in% europe
)
```

:::


```{r}
ibd_eur %>%
ggplot() +
  geom_jitter(aes(length, pair))
```

```{r}
summary_df <-
  ibd_eur %>%
  group_by(pair) %>%
  summarize(mean_length = mean(length), total_length = sum(length))
```

```{r}
summary_df %>%
  ggplot() +
  geom_point(aes(mean_length, pair))
```

```{r}
library(forcats)

ibd_eur %>%
  group_by(pair) %>%
  summarize(mean_length = mean(length)) %>%
  ggplot() +
  geom_point(aes(mean_length, fct_reorder(pair, mean_length)))
```

```{r}
summary_df <-
  ibd_eur %>%
  group_by(pair) %>%
  summarize(mean_length = mean(length), total_length = sum(length)) %>%
  pivot_longer(
    cols = c(mean_length, total_length),
    names_to = "statistic",
    values_to = "value"
  )
```

```{r}
ggplot(summary_df) +
  geom_point(aes(value, pair)) +
  facet_wrap(~ statistic)
```

```{r}
ggplot(summary_df) +
  geom_point(aes(value, fct_reorder(pair, value))) +
  facet_wrap(~ statistic, scales = "free_x")
```

```{r}
library(tidytext)

ggplot(summary_df) +
  geom_point(aes(value, reorder_within(pair, value, within = statistic))) +
  facet_wrap(~ statistic, scales = "free")
```

```{r}
p_mean <-
  filter(summary_df, statistic == "mean_length") %>%
  ggplot +
  geom_point(aes(value, fct_reorder(pair, value))) +
  facet_wrap(~ statistic, scales = "free_x")

p_mean
```


```{r}
p_sum <-
  filter(summary_df, statistic == "total_length") %>%
  ggplot +
  geom_point(aes(value, fct_reorder(pair, value))) +
  facet_wrap(~ statistic, scales = "free_x")

p_sum
```

```{r}
library(cowplot)

plot_grid(p_mean, p_sum)
```



## Further practice

I'm sure you have done some form of table munging and data visualization in your
projects. If you're done with the exercises above, here are some ideas for you:

1. If you haven't used R for processing of tabular data in your work -- maybe
you have done similar table munging in Excel or Google Sheets in a manual
(i.e., non-reproducible) way? -- write your processing steps as a self-contained
R script:

- If you used Excel, you can use the R package [_readxl_](https://readxl.tidyverse.org),
- If you used Google Sheets, you can use the R package [_googlesheets4_](https://googlesheets4.tidyverse.org)

2. If you used Excel or base R for plotting figures, use what you learned
about _ggplot2_ to make beautiful, publication-ready plots as we did in our
exercises.

Yes, this will put you in an uncharted territory. This is scary and totally
normal when doing research. I'm happy to help you out with questions
and issues!