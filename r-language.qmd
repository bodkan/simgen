# R programming language

⚠️⚠️⚠️
**This chapter is a work-in-progress!**
⚠️⚠️⚠️

In a wider programming world, R sometimes has a slightly unfortunate reputation
as a badly designed "calculator language". A computing environment which is
(maybe!) good for working with data frames and creating figures, but that's about
it. However, while certainly very useful for data science, R is a full-blown
programming language which is actually quite powerful even from a purely
computer science perspective.

But still, this is a book about population genomics and data science in R.
Why does this matter how much "real coding" we do in it?

Well, although this entire workshop will primarily focus on R primarily as 
as a statistical and visualization environment, neglecting the aspects of R
which make it a "proper" programming language (or even considering data science
as "not real programming") is a huge problem.

First, even when "just" doing data science and statistics, we still use typical
programming constructs, we need to be aware of underlying data types behind
our data (mostly contents of tables), and we need to think algorithmically.
Neglecting these things makes it easy to introduce bugs into our code, make
it hard to find those bugs, and make our programs less efficient even when
they do work.

This chapter will help you get familiar with some of the less obvious aspects
of the R language or programming in general, certainly the parts which are often
skipped in undergratuate courses in the life sciences in favor of just teaching
plotting and running statistical tests. The good thing is, there isn't that much
you need to learn. And what you do learn will continue paying dividents for the
rest of your research career!

Let's say it again, because people with non-computational backgrounds often feel
inadequate when it comes to computational aspects of their work: **Even when you're
"just" writing data analysis scripts, even when you're "just" plotting results,
you're still writing programs. You're a programmer.** How exciting, right?
Exercises in this chapter are designed to make you comfortable with programming
and algorithmic thinking.

## Part 1: Basic data types

**Create the following variables in your R script and then evaluate this code
in your R console:**

::: {.aside}
**Hint:** I suggest you always write your code in a script in RStudio (click
File -> New file -> R script). You can execute the line (or block) of code
under cursor in the script window by pressing CTRL+Enter (on Windows or Linux)
or CMD+Enter (on a Mac). For quick tests, feel free to type directly in the
R console.
:::

```{r}
w1 <- 3.14
x1 <- 42
y1 <- "hello"
z1 <- TRUE
```

```{r}
w1
x1
y1
z1
```

**What are the data "types" you get when you apply function `mode()` on each of
these variables?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
mode(w1)
mode(x1)
mode(y1)
mode(z1)
```
:::

You can test whether or not a specific variable is of a specific type using
functions such as `is.numeric()`, `is.integer()`, `is.character()`, `is.logical()`. **See what results you get when you apply these functions on these
four variables `w1`, `x1`, `y1`, `z1`. Pay close attention to the difference
(or lack thereof?) between applying `is.numeric()` and `is.integer()` on
variables containing "numbers".**

::: {.aside}
**Note: This might seem incredibly boring and useless but trust me. In your
real data, you will be see, in data frames (discussed below) with thousands of
rows, sometimes millions. Being able to make sure that the values you get
in your data-frame columns are of the expected type is something you will be
doing often.
:::

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
is.numeric(w1)
is.integer(w1)

is.numeric(x1)
is.integer(x1)

is.character(y1)

is.logical(z1)
is.numeric(z1)
is.integer(z1)
```

:::

To summarize (and oversimplify a little bit) R allows variables to have several
types of data, most importantly:

- integers (such as `42`)
- numerics (such as `42.13`)
- characters (such as `"text value"`)
- logicals (`TRUE` or `FALSE`)

**We will also encounter two types of "non-values". We will not be discussing
them in detail here, but they will be relevant later. For the time being, just
remember that there are also:**

- undefined values represented by `NULL`
- missing values represented by `NA`

**What do you think is the practical difference between `NULL` and `NA`? In
other words, when you encounter one or the other in the data, how would you
interpret this?**


## Part 2: Vectors

Vectors are, roughly speaking, collections of values. We could also say "a list",
but that's not entirely precise in the context of R as we'll see below.

We can create a vector by calling the `c()` function ("c" stands for
"concatenate", or "joining together"). **Create the following variables containing
these vectors. Then inspect their data types using `mode()` again.**

```{r}
w2 <- c(1.0, 2.72, 3.14)
x2 <- c(1, 13, 42)
y2 <- c("hello", "folks", "!")
z2 <- c(TRUE, FALSE)
```

```{r}
w2
x2
y2
z2
```

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution
```{r}
mode(w2)
mode(x2)
mode(y2)
mode(z2)
```
:::

**We can use the function `is.vector()` to test that a given object really is a
vector. Try this on your vector variables.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution
```{r}
is.vector(w2)
is.vector(x2)
is.vector(y2)
is.vector(z2)
```
:::

**What happens when you call `is.vector()` on the variables `x1`, `y1,` etc. from
the previous part (i.e., those which contain single values)?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
is.vector(42)
```

Yes, even scalars (i.e., singular values) are formally vectors!

This is why we see the [1] index when we type a single number:

```{r}
1
```


In fact, even when we create a vector of length 1, we still get a scalar result:

```{r}
c(1)
```

The conclusion is, R doesn't actually distinguish between scalars and vectors!
A scalar (a single value) is simply a vector of length 1. Think of it this way:
in a strange mathematically-focused way, even a single tree is a forest. 🙃
:::

**Do elements of vectors need to be homogeneous (i.e., of the same data type)?
Try creating a vector with values `1`, `"42"`, and `"hello"`. Can you do it?
What happens when you try? Inspect the result in the R console (take a close look
at how the result is presented in text and the quotes that you will see), or
use the `mode()` function again.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
mixed_vector <- c(1, "42", "hello")
mixed_vector
```

```{r}
mode(mixed_vector)
```
:::

As you could see, vectors must carry values of just one type. If they don't, they
are converted by a straightforward cascade of so-called "coercions". A vector
defined with a mixture of different values (i.e., the four atomic types we
discussed in the first part) will be _coreced_ to be only one of those types,
given certain rules.

**Try to figure out some of these coercion rules. Make a couple of vectors
with mixed values of different types using the function `c()`, and observe
what type of vector you get in return.**

**Hint:** Try creating a vector which has integers and strings, integers and
floats, integers and logicals, floats and logicals, floats and strings, and
logicals and strings. Observe the format of the result that you get, and
build your intuition by calling `mode()` on each vector object to verify this.

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution
```{r}
v1 <- c(1, "42", "hello")
v1
mode(v1)

v2 <- c(1, 42.13, 123)
v2
mode(v2)

v3 <- c(1, 42, TRUE)
v3
mode(v3)

v4 <- c(1.12, 42.13, FALSE)
v4
mode(v4)

v5 <- c(42.13, "hello")
v5
mode(v5)

v6 <- c(TRUE, "hello")
v6
mode(v6)
```
:::

**Out of all these data type exploration, this part is probably the most crucial
for any kind of data science work. Why is that? Think about what can happen when
someone does manual data entry in Excel.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution
Imagine what kinds of trouble can happen if you just load a table data from
somewhere, if the values are not properly formatted. For instance, if a "numeric"
column of your table has accidentally some characters (which can very easily
happen when manually entering data in Excel, etc.). This will be much clearer
when we get to data frames below.
:::

**You can create vector of consecutive values of certain forms using everal
approaches. Try these options:**

1. **Create a sequence of values from `i` to `j` as `i:j`. Create a vector of
numbers 1:20**

2. **Do the same using the function `seq()`. Read `?seq` to find out what
parameters you should specify (and how) to get the same result as the `i:j`
shortcut.

3. **Modify the arguments given to `seq()` so that you create a vector of
numbers from 20 to 1.**

4. **Use the `by =` argument of `seq()` to create a vector of only odd
values starting from 1.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
# 1
1:20
# another option is this ("give me sequence of the length N)
seq_len(20)

# 2
seq(from = 1, to = 20)

# 3
seq(from = 20, to = 1)

# 4
seq(1, 20, by = 2)
```

This might look boring, but these functions are super useful to generate
indices for data, adding indices as columns to tabular data, etc.**
:::

**Another very useful built-in helper function (especially when we get to
the iteration part below) is `seq_along()`. What does it give you when you run
it on this vector, for instance?**

```{r}
v <- c(1, "42", "hello", 3.1416)
```

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
seq_along(v)
```

This function allows you to quickly iterate over elements of a vector (or a list)
using indices into that vector (or a list).
:::

## Part 3: Lists

Lists are a little similar to vectors but very different in a couple of important
respects. Remember how we tested what happens when we put different types of
values in a vector (reminder: vectors must be "homogeneous" in terms of the
data types of their elements!)? **What happens when you create lists with
different types of values using the code in the following chunk? Use `mode()`
on the resulting objects and compare your results to those you got on "mixed
value" vectors above.**

```{r}
w3 <- list(1.0, "2.72", 3.14)
x3 <- list(1, 13, 42, "billion")
y3 <- list("hello", "folks", "!", 123, "wow a number follows again", 42)
z3 <- list(TRUE, FALSE, 13, "string")
```

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

When we type the list variable in the R console, we no longer see the "coercion"
we observed for vectors (numbers remain numbers even though the list contains
strings):

```{r}
y3
```

**Calling `mode()` will (disappointingly) not tell us much about the data types
of each individual element. Why is that?**

```{r}
mode(y3)
```
:::

**Try also a different function called for `str()` (for "structure") and apply
it on one of those lists. Is `mode()` or `str()` more useful to inspect what
kind of data is stored in a list (`str` will be very useful when we get to data
frames for -- spoiler alert! -- exactly this reason). Why?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
str(y3)
```
:::

```{r}
is.list(w3)
```

**Use `is.vector()` and `is.list()` on one of the lists above (like `w3` perhaps).
Why do you get the result that you got? Then run both functions on one of the
vectors you created above (like `w2`). What does this mean?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

- Let's take this list:

```{r}
w3
```

Lists are vectors!

```{r}
is.vector(w3)
```

Lists are lists (obviously!):

```{r}
is.list(w3)
```

- Now let's take this vector:

```{r}
w2
```

Vectors are not lists!

```{r}
is.list(w2)
```

So:

1. Every list is also a vector.
2. But vectors are not lists.

This makes sense because lists can (but don't have to) contain values
:::


Not only can lists contain arbitrary values of mixed types (atomic data
types from Part 1 of this exercise), they can also contain non-atomic data
as well, such as other lists! In fact, you can, in principle, create lists
of lists of lists of... lists! **Try creating a `list()` which, in addition
to a couple of normal values (numbers, strings, doesn't matter) also contains
one or two other lists (we call them "nested"). Don't think about this too much,
just create something arbitrary to get a bit of practice. Save this in a
variable called `weird_list` and type it back in your R console, just to see
how R presents such data back to you. In the next part, we will learn how to
explore this type of data better.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Here's an example of such "nested list":

```{r}
weird_list <- list(
  1,
  "two",
  list(
    "three",
    4,
    list(5, "six", 7)
  )
)
```

When we type it out in the R console, we see that R tries to lay out the
structure of this data with numerical indices (we'll talk about indices below!)
indicating the "depth" of each nested pieces of data (either a plain number or
character, or another list!)

```{r}
weird_list
```
:::

**Note:** If you are confused (or even annoyed) why we are even doing this,
in the later discussion of data frames and spatial data structures, it
will become much clearer why putting lists into other lists allows a whole
another level of data science work. Please bear with me for now! This is
just laying the groundwork for some very cool things later down the line.


## Part 4: Indexing into vectors and lists

To extract a specific element(s) of a vector or a list (or to assign its given
position(s)), we use a so-called "indexing" operation. Generally speaking,
we can do indexing in three ways:

1. **numerical-based indexing** (by specifying a set of integer numbers),

2. **logical-based indexing** (by specifying a vector of `TRUE` / `FALSE` values of the
same length as the vector we're indexing into)

3. **name-based indexing** (by specifying names of elements to index)

Let's practice those for vectors and lists separately. Later, when we introduce
data frames, we will return to the topic of indexing again.

### Vectors

#### 1. Numerical-based indexing

To extract an i-th element of a vector `xyz`, we can use the `[]` operator like
this: `xyz[i]`. For instance, we can take the 13-th element of this vector
as `xyz[13]`.

**Familiarize yourselves with the `[]` operator by taking out some specific
values from this vector, let's say its 5-th element.**

```{r}
v <- c("hi", "folks", "what's", "up", "folks")
```

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
v[5]
```
:::

The `[]` operator is "vectorized", meaning that it can actually accept multiple
values given as a vector themselves (i.e, something like `v[c(1, 3, 4)]` will
extract the first, third, and fourth element of the vector `v`. **In this way,
extract the first and fifth element of the vector `v`. What happens if you
try to extract a tenth element from `v`?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
v[c(1, 5)]
```

Accessing a non-existent element gives us a "not available" or "missing" value.

```{r}
v[10]
```

:::


#### 2. Logical-based indexing

Rather than giving the `[]` operator a specific set of integer numbers, we
can provide a vector of `TRUE` / `FALSE` values which specify which element
of the input vector do we want to "extract". Note that this `TRUE` / `FALSE`
indexing vector must have the same length as our original vector!

**Create variable containing a vector of five `TRUE` or `FALSE` values (i.e.,
with something like `index <- c(TRUE, FALSE, ...)` but with five `TRUE` or `FALSE`
values total, and use that `index` variable in a `v[index]` indexing operation.**

```{r}
index <- c(TRUE, FALSE, TRUE, TRUE, FALSE)
v[index]
```


Usually we never want to create this "indexing vector" manually (imagine doing
this for a vector of million values -- impossible!). Instead, we create this
indexing vector "programmatically", based on a certain condition, like this:

```{r}
index <- v == "up"
```

This checks which values of `v` are equal to "three", creating a logical `TRUE` /
`FALSE` vector in the process, storing it in the variable `index`:

```{r}
index
```

**Use the same principle to extract the elements of the vector matching the
value "folks".**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
index <- v == "folks"
index
```

A nice trick is that summing a logical vector using `sum()` gives you the
number of `TRUE` matches:

```{r}
sum(index)
```

This is actually why we do this indexing operation on vectors in the first places, most
of the time -- when we want to count how many data points match a certain criterion.

Let's extract our matching values:

```{r}
v[index]
```
:::




### Lists

This section will be a repetition on the previous exercises about vectors.
**Don't forget -- lists are just vectors, except that they can contain
values of heterogeneous types (numbers, characters, anything). As a result,
everything that applies to vectors above applies also here.**

But practice makes perfect, so let's go through a couple of examples anyway:

```{r}
l <- list("hello", "folks", "!", 123, "wow a number follows again", 42)
l
```

#### 1. Numerical-based indexing

The same applies to numerical-based indexing as what we've shown for vectors.

**Extract the second and fourth elements from `l`.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
l[c(2, 4)]
```
:::

#### 2. Logical-based indexing

Similarly, you can do the same with `TRUE` / `FALSE` indexing vectors for lists
as what we did with normal (single-type) vectors. There's no point in having
you go through all this, because it would be very boring.

#### `[]` vs `[[]]` operators

Let's move to a more interesting topic. There's another operator useful for
lists, and that's `[[ ]]` (not `[ ]`!). **Extract the third element of the list
`l` using `l[4]` and `l[[4]]]`. What's the difference between the results?
If you're unsure, use the `mode()` function on `l[3]` and `l[[3]]` to help you.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Strange, isn't it? The `[ ]` operator seems to return a list, even though
we expect the result `123`?

```{r}
l[4]

mode(l[4])
```

On the other hand, `l[[4]]` gives us just a number!

```{r}
l[[4]]

mode(l[[4]])
```

I simply cannot not link to [this](https://r4ds.hadley.nz/diagrams/pepper.png)
brilliant figure, which explains this result in a very fun way. The left
picture shows our list `l`, the middle picture shows `l[4]`, the right picture
shows `l[[4]]`. Spend some time experimenting with the behavior of `[ ]` and
`[[ ]]` on our list `l`! This will come in handy many times in your R carreer!
:::



### Traversing nested lists

Remember our nested list from earlier? Here's it again:

```{r}
weird_list <- list(
  1,
  "two",
  list(
    "three",
    4,
    list(
      5, "six",
      list("seven", 8)
    )
  )
)
```

**What do you get when you run `weird_list[[1]]`? How about `weird_list[[3]]`?
And how about `weird_list[[3]][[2]]`?** Things are getting a little complicated
(or interesting, depending on how nerdy you are :)).

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

This takes out the first value of the list:

```{r}
weird_list[[1]]
```

Note the `[[]]` operator. Here's what we would get with the `[]` operator
(basically, a "sublist"):

```{r}
weird_list[1]

mode(weird_list[1])
```

This extracts the 3rd value, which is itself a list!

```{r}
weird_list[[3]]
```

And because this is just any other list (just nested), we can also index
_into that list_! Glancing at the result of `weird_list[[3]]` just above,
we see that the 2nd value of that list is a number 4. Let's verify that:

```{r}
weird_list[[3]][[2]]
```
:::

**What's the sequence of this "chaining" of indexing operators to extract
the number 8?**

**Hint:** You can leverage the interactive nature of evaluating intermediate
results in the R console, adding things to the expression (i.e., a chunk
of code) in sequence.

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Let's take it step by step, interactively:

1. We know that the nested list sits at the 3rd position of the whole list:

```{r}
weird_list[[3]]
```

2. The other nested list is at index number 3 again:

```{r}
weird_list[[3]][[3]]
```

3. And the final list, the one carrying the number 8, is again in the 3rd position:

```{r}
weird_list[[3]][[3]][[3]]
```

4. Finally, we can extract the number 8 from the index at the second position:

```{r}
weird_list[[3]][[3]][[3]][[2]]
```

_Whew!_ That was something, wasn't it. Kind of annoying, if you ask me.

Luckily, you will not have to do these kind of complex shenanigans in R very
often (maybe even never). Still, nested lists are sometimes used in capturing
more complex types of data than just lists of numbers or tables (for instance,
nested lists capture tree-like structures). In any case, using _names_ instead
of just _integers_ as indices makes the whole process much easier, as we will
see below.

In data you encounter in practice, the most extreme case of data indexing you
will have to do probably won't be more complex than two nested indexing
operators in a row (i.e., the equivalent of doing `data[[2]][[3]])`.

Particularly when we discuss some very convenient _tidyverse_ operations later,
having an idea about what a nested list even is will be very useful, so bear
with me please!
:::








### Named indexing for vectors and lists


Here's a neat thing we can do with vectors and lists. They don't have to contain
just values themselves (which can be then extracted using integer or logical
indices as we've done above), but those values can be assigned names too.

Consider this vector and list:

```{r}
v <- c(1, 2, 3, 4, 5)
v

l <- list(1, 2, 3, 4, 5)
l
```

As a recap, we can index into them in the usual manner like this:

```{r}
v[c(1, 3, 5)]
l[c(1, 3)]
```

But we can also name the values like this (note that the names appear in the
print out you get from R in the console):

```{r}
v <- c(one = 1, two = 2, three = 3, four = 4, five = 5)
v

l <- list(one = 1, two = 2, three = 3, four = 4, five = 5)
l
```

When you have a named data structure like this, you can index into it using
those names as well, which can be very convenient. Imagine having data described
not by indices but actualy readable names (such as names of people, or excavation
sites!):

```{r}
l[["three"]]

l[c("two", "five")]
```


--

_Spoiler alert: this is exactly what data frames are, under the hood
(named lists!), as we'll see in the next section._

--

Let's return (one last time, I promise!) to our nested list example, this
time presenting it in a more convenient way.

```{r}
weird_list <- list(
  1,
  "two",
  nested1 = list(
    "three",
    4,
    nested2 = list(
      5, "six",
      nested3 = list("seven", 8)
    )
  )
)
```

With a list like that, when we previously had to extract the element 8 like this:

```{r}
weird_list[[3]][[3]][[3]][[2]]
```

we can now do this:

```{r}
weird_list[["nested1"]][["nested2"]][["nested3"]][[2]]
```

Much more readable!





### Negative indexing


Consider this vector again:

```{r}
v <- c("hi", "folks", "what's", "up", "folks")
```

**What happens when you index into `v` using the `[]` operator but give it
a negative number between 1 and 5?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Negative indices remove elements!

```{r}
v[-1]
```

When we exclude all indices `1:5`, we remove everything, oops!

```{r}
v[-(1:5)]
```

:::

A very useful function is `length()`, which gives the length of a given
vector (or a list -- remember, lists are vectors!). **Use it to remove
the last element of `v`. How would you remove both the first and last
element of a vector or a list (assuming you don't know the length beforehand,
i.e., you can't put a fixed number as the index of the last element)?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
v[-length(v)]
```

```{r}
# this gives us the index of the first and last element
c(1, length(v))

# then we can prefix this with the minus sign to remove them
v[-c(1, length(v))]
```

:::








## Part 5: Data frames

Every scientists works with tables of data, in one way or another. R provides
first class support for working with tables, which are formally called
"data frames". We will be spending most of our time of this workshop learning
to manipulate, filter, modify, and plot data frames, often times with data
that is too big to look at all at once. For simplicity, just to get started
and to explain the basic fundamentals, let's begin with something trivially
easy, like this little data frame here:

```{r}
df <- data.frame(
  v = c("one", "two", "three", "four", "five"),
  w = c(1.0, 2.72, 3.14, 1000.1, 1e6),
  x = c(1, 13, 42, 123, 0),
  y = c("folks", "hello", "from", "data frame", "!"),
  z = c(TRUE, FALSE, FALSE, TRUE, TRUE)
)

df
```

First, here's the first killer bit of information: data frames are normal lists!

```{r}
is.list(df)
```

How is this even possible? And why is this even the case?
Explaining this in full would be too much detail,
even for a course which tries to go beyond "R only as a plotting tool" as I
promised you in the introduction. Still, for now let's say that R objects
can store so called "attributes", which -- in the case of data frame objects --
makes them behave as "something more than just a list". These attributes are
called "classes".

**You can poke into these internals but "unclassing" an object. Call `unclass(df)`
in your R console and observe what result you get (just to convince yourself
that data frames really are lists under the hood).**

::: {.aside}
**Note:** Honest admission -- you will never need this `unclass()` stuff in
practice, ever. I'm really showing you to demonstrate what "data frame" actually
is on a lower-level of R programming. If you're confused, don't worry. The fact
that data frames are lists matters infinitely more than knowing exactly how
is that accomplished inside R.
:::

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

This is what a normal data frame looks like to us:

```{r}
df
```

Here is how a data frame is represented under the hood:

```{r}
unclass(df)
```

It really is just a list!
:::


Remember how we talked about "named lists" in the previous section! Yes, data
frames really are just normal named lists with extra bit of behavior added
to them (namely the fact that these lists are printed in a nice, readable, 
tabular form).

### Selecting columns

Quite often we need to extract values of an entire column of a data frame. In
the Part about indexing, you have learned about the `[]` operator (for vectors
and lists), and also about the `$` and `[[]]` operator (for lists). Now that
you've learned that data frames are (on a lower level) just lists, what does
it mean for wanting to extract a column from a data frame?

**Try to use the three indexing options to extract the column named `"z"`
from your data frame `df`. How do the results differ depending on the indexing
method chosen? Is the indexing (and its result) different to indexing a
plain list?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

We can extract a given column with...

1. the `$` operator (column name as a symbol), which gives us a vector:

```{r}
df$z
```

2. the `[` operator (column name as a string), which gives us a (single-column)
data frame:

```{r}
df["z"]
```

3. the `[[` operator (column name as a string), which gives us vector again:

```{r}
df[["w"]]
```

Let's create a list-version of this data frame:

```{r}
df_list <- as.list(df)
df_list
```

The indexing results match what we get for the data frame. After all, a data
frame really is just list (with some very convenient behavior, such as
presenting the data in a tabular form). The only exception is the result
of `df_list["v"]` which results a data frame but only returns a list when
applied on a list:

```{r}
df_list$v
df_list["v"]
df_list[["v"]]
```
:::

#### The _tidyverse_ approach

In the chapter on _tidyverse_, we will learn much more powerful and easier
tools to do these types of data-frame operations, particularly the `select()`
function. That said, even when you use _tidyverse_ exclusively, you will
still encounter code in the wild which uses this base R way of doing things.
Additionally, for certain trivial actions, doing "the base R thing" is just
quicker to types. This is why knowing the basics of `$`, `[]`, and `[[]]` will
always be useful.


### Selecting rows ("filtering")

Of course, we often need to refer not just to specific columns of data frames,
but also to given rows. Let's consider our data frame again:

```{r}
df
```

In the section on indexing into vectors and lists above, we learned primarily
about two means of indexing into vectors. Let's revisit them in the context
of data frames:

1. **Integer-based indexing**

**What happens when you use the `[1:3]` index into the `df` data frame, just
as you would do by extracting the first three elements of a vector?

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Somewhat curiously, you get the first three columns, not rows!

```{r}
df[1:3]
```
:::

When indexing into a data frame (or even a matrix, although we won't be getting
into those in our course), you need to distinguish the _dimension_ along which
you're indexing: either a row, or a column dimension. Just like in referring to
a cell coordinate in Excel, for example.

The way you do this for data frames in R is to separate the dimensions into
which you're indexing with a comma in this way: `[row-index, column-name-or-index]`.
**Try to extract the first three elements (`1:3`) of the data frame `df` by
`df[1:3, ]`.** Note the empty space after the comma `,`! **Then try to
select a subset of the `df` data frame to only show the row #1 and #4 for
columns `"x"` and `"z"`.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Extract the first three rows of `df`:

```{r}
df[1:3, ]
```

Extract the rows number 1 and 4 for columns "x" and "z":

```{r}
df[c(1, 4), c("x", "z")]
```

Of course, the actual indexing dimensions can be (and often is) specified in
variables. For instance, we often have code which firsts computes the indexes,
and then we access them into the data frames. The equivalent of this here would
be:

```{r}
row_indices <- 1:3

df[row_indices, ]
```

Extract the rows number 1 and 4 for columns "x" and "z":

```{r}
row_indices <- c(1, 4)
col_indices <- c("x", "z")

df[row_indices, col_indices]
```


2. **Logical-based indexing**

Similarly to indexing into vectors, you can also specify which rows should
be extracted "at once", using a single logical vector (you can also do this
for columns but I honestly don't remember the last time I had to do this). 

**The most frequent use for this is to select all rows of a data frame for
which a given column (or multiple columns) carry a certain value. Select
only those rows for which the column "y" has a value "hello"**:

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Let's first use a vectorized comparison to get a `TRUE` / `FALSE` vector
indicating which values of the "v" column contain the string "hello".
Remember, that if you take a vector (of arbitrary length) and compare it
to some value, you will get a `TRUE` / `FALSE` vector of the same length:

```{r}
# this is what the column (vector, really) contains
df$y
```

```{r}
# this is how we can find out, which element(s) of the vector match
df$y == "hello"
```

```{r}
# let's save the result to a new variable
row_indices <- df$y == "hello"
row_indices
```
:::

Now we can use this vector as a row index into our data frame (don't forget
the comma `,`, without which you'd be indexing into the column-dimension,
not the row-dimension!).

```{r}
df[row_indices, ]
```

Of course, you can also both _filter_ (remember this word) for a subset of rows
and also, at the same time, _select_ (remember this word too) a subset of
columns at the same time:

```{r}
df[row_indices, c("v", "y", "z")]
```
:::

**Now instead of filtering rows where column `y` matches "hello", filter for rows
where `w` column is less than 1000.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

We can again store the filtered rows in a separate variable, and then use that
variable to index into the data frame:

```{r}
row_indices <- df$w < 1000
row_indices

df[row_indices, ]
```

Often, we want to be more consise and do everything in one go:

```{r}
df[df$w < 1000, ]
```
:::


#### Creating (and deleting) columns

The `$` and `[]` operators can be used to create new columns. For instance,
the `paste()` function in R can be used to combine a pair of values into one.
Try running `paste(df$v, df$y)` to see what the result of this operation is.

The general pattern to do this is:

```{r}
#| eval: false
df$<name of the new column> <- <vector of values to assign to it>
```

**Create a new column called `"new_col"` and assign to it the result of
`paste(df$v, df$y)`.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
df["new_col"] <- paste(df$v, df$y)

# new column appears!
df
```
:::

When we want to remove a column from a data frame (for instance, we only used
it to store some temporary result in a script), we actually do the same thing,
except we assign to it the value `NULL`.

**Remove the column `new_col`**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
df$new_col <- NULL

# and the column is gone
df
```
:::


#### "Improper" column names

Most column names you will be using in your own script will (well, should!) follow
the same rules as apply for variable names -- they can't start with a number,
have to compose of alphanumeric characters, and can't contain any other characters
except for underscores (and occasionally dots). To quote from the venerable
[R language reference](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Identifiers):

> Identifiers consist of a sequence of letters, digits, the period (‘.’) and the underscore. They must not start with a digit or an underscore, or with a period followed by a digit.

For instance, these are examples of proper identifiers which can serve as
variable names, column names and (later) function names:

- `variable1`
- `a_longer_var_42`
- `anotherVariableName`

Unfortunately, when you encounter data in the wild, especially in tables you
get from other people or download as supplementary information from the internet,
they are rarely this perfect. Here's a little example of such data frame:

```{r}
#| echo: false
weird_df <- data.frame(
  `v with spaces` = c("one", "two", "three", "four", "five"),
  w = c(1.0, 2.72, 3.14, 1000.1, 1e6),
  `y with % sign` = c("folks", "hello", "from", "data frame", "!")
)
names(weird_df) <- c("v with spaces", "w", "y with % sign")
```

```{r}
weird_df
```

If you look closely, you see that some columns have spaces `" "` and also strange
characters `%` which are not allowed? Which of the `$`, `[]` and `[[]]` operators
can you use to extract `v with spaces` and `y with % sign` columns as vectors?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

`[]` and `[[]]` work just as before, because they accept a string by default
anyway, so spaces and other characters are not a problem:

```{r}
weird_df["v with spaces"]

weird_df[["y with % sign"]]
```

The `$` operator needs bit more work. When you encounter an "improper" column
name in a data frame, you have to enclose the whole "symbol" or "identifier"
in "back ticks" like this:

```{r}
weird_df$`y with % sign`
```

This is super useful when working with tabular data you get from someone else,
especially if they prepared it in Excel. But you should never create data
frames with these weird column names yourself. Always use names that would
be appropriate as normal standard R identifiers on their own (just alphanumeric
symbols or underscores).
:::




#### The _tidyverse_ approach

Similarly to previous section on column selection, there's a much more convenient
and faster-to-type way of doing filtering, using the _tidyverse_ function `filter()`.
Still, as with the column selection, sometimes doing the quick and easy thing
is just more convenient. The minimum on filtering rows of data frames introduced
in this section will be enough for you, even in the long run!


## Part 6: Inspecting column types

Let's go back to our example data frame:

```{r}
df1 <- data.frame(
  w = c(1.0, 2.72, 3.14),
  x = c(1, 13, 42),
  y = c("hello", "folks", "!"),
  z = c(TRUE, FALSE, FALSE)
)

df1
```

**Use the function `str()` and by calling `str(df1)`, inspect the types of
columns in the table.**

```{r}
str(df1)
```

Sometimes (usually when we read data from disk, like from another software),
a data point sneaks in which makes a column apparently non numeric. Consider
this new table called `df2`:

```{r}
df2 <- data.frame(
  w = c(1.0, 2.72, 3.14),
  x = c(1, "13", 42),
  y = c("hello", "folks", "!"),
  z = c(TRUE, FALSE, FALSE)
)

df2
```

Just by looking at this, the table looks the same as `df1` above. **Use `str()`
again to see where the problem is.**

```{r}
str(df2)
```



## Part 7: Functions

The motivation for this part could be summarized by an ancient motto of programming:
[Don't repeat yourself (DRY)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself):
_"[...] a modification of any single element of a system does not require
a change in other logically unrelated elements."_.

Let's demonstrate this idea in practice.

Let's say you have the following numeric vector (these could be base qualities,
genotype qualities, $f$-statistics, sequencing coverage, anything):

```{r}
vec <- c(0.32, 0.78, 0.68, 0.28, 1.96, 0.21, 0.07, 1.01, 0.06, 0.74,
         0.37, 0.6, 0.08, 1.81, 0.65, 1.23, 1.28, 0.11, 1.74,  1.68)
```

With numeric vectors, we often need to compute some summary statistics
(mean, median, quartile, minimum, maximum, etc.). What's more, in a given project,
we often have to do this computation multiple times in a number of places.

::: {.aside}
In R, we have a very useful built-in function `summary()`, which does exactly that.
But let's ignore this for the moment, for learning purposes.
:::

Here is how we can compute those summary statistics individually:

```{r}
min(vec)

# first quartile (a value which is higher than the bottom 25% of the data)
quantile(vec, probs = 0.25)

median(vec)

mean(vec)

# third quartile (a value which is higher than the bottom 75% of the data)
quantile(vec, probs = 0.75)

max(vec)
```

Now, you can imagine that you have many more of such vectors (results for different
sequenced samples, different computed population genetic metrics, etc.). Having
to type out all of these commands for every single one of those vectors would
very quickly get extremely tiresome. Worse still, when we would do this, we would
certainly resort to copy-pasting, which is guaranteed to lead to errors.

**Write a custom function called `my_summary`, which will accept a single input
named `values`, and returns a list which binds all the six summary statistics
together. Name the elements of that list as `"min"`, `"quartile_1"`, `"median"`,
`"mean"`, `"quartile_3"`, and `"max"`.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

Here is how we could write the function:

```{r}
my_summary <- function(values) {
  a <- min(vec)
  b <- quantile(vec, probs = 0.25)
  c <- median(vec)
  d <- mean(vec)
  e <- quantile(vec, probs = 0.75)
  f <- max(vec)
  
  result <- list(min = a, quartile_1 = b, median = c, mean = d, quartile_3 = e, max = f)
  
  return(result)
}
```

Although I would probably prefer to write it a bit more tersely like this:

```{r}
my_summary <- function(values) {
  result <- list(
    min = min(vec),
    quartile_1 = quantile(vec, probs = 0.25),
    median = median(vec),
    mean = mean(vec),
    quartile_3 = quantile(vec, probs = 0.75),
    max = max(vec)
  )
  
  return(result)
}
```
:::

Let's acknowledge one thing straight away: yes, we had to write the code anyway,
we even had to do the extra work of wrapping it inside other code (the `function`
body, name the one input argument `values`, which could be multiple arguments
for more complex function). So, one could argue that we didn't actually save any
time. However, that code is now "encapsulated" in a fully self-contained form
and can be called repeatably, without any copy-pasting.

In other words, if you now **create these three vectors of numeric values**:

```{r}
vec1 <- runif(10)
vec2 <- runif(10)
vec3 <- runif(10)
```

You can now **compute our summary statistics by calling our function `my_summary()`
on these vectors, without any code repetition**:

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
my_summary(vec1)
my_summary(vec2)
my_summary(vec3)
```

And, surprise! This is what the incredibly useful built-in function `summary()`
provided with every R installation does!

```{r}
summary(vec1)
summary(vec2)
summary(vec3)
```
:::

The punchline is this: if we ever need to modify how are summary statistics
are computed, _we only have to make a single change in the function code
instead of having to modify multiple copies of the code in multiple locations
in our project_.




## Part 8: Iteration and loops

Functions help us take pieces of code and _generalize_ them to reduce the amount
of code needed to do similar things, repeatedly, multiple times. You could think
of _iteration_ as generalizing those repetitions.

This is very vague and abstract




## Part 9: Base R plotting

As a final short section, it's worth pointing out some very basic base R plotting
functions. We won't be getting into detail because _tidyverse_ provides a
much more powerful and more convenient set of functionality for visualizing data.
Still, base R is often convenient for quick troubleshooting or quick plotting
of data at least in the initial phases of data exploration.

So far we've worked with a really oversimplified data frame. For more interesting
demonstration, R bundles with a realistic data frame of penguin data:

```{r}
head(penguins)
```

```{r}
#| echo: false
penguins <- penguins[!is.na(penguins$sex), ]
```


**Use the function `hist()` to plot a histogram of the body mass of the entire
penguins data set.**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
hist(penguins$body_mass)
```

Sometimes it is convenient to adjust the bin width:

```{r}
hist(penguins$body_mass, breaks = 50)
```
:::

The dataset also contains the measure of bill length. **Use the function `plot()`
to visualize a scatter plot of two vectors: `penguins$flipper_len` against
`penguins$body_mass`. Is there an indication of a relationship between the two
metrics?**

::: {.callout-note collapse="true" icon=false}
#### Click to see the solution

```{r}
plot(penguins$flipper_len, penguins$body_mass)

# we can also overlay a linear fit (first computed with the `lm()` function,
# then visualized as a red dashed line)
lm_fit <- lm(body_mass ~ flipper_len, data = penguins)
abline(lm_fit, col = "red", lty = 2)
```

We can also see that we have data for three different species of penguins.
We can therefore partition the visualization for each species individually:

```{r}
plot(penguins$flipper_len, penguins$body_mass, col = penguins$species)
```
:::

Base R plotting is very convenient for quick and dirty data summaries, particularly
immediately after reading unknown data. However, for anything more complex
(and anything more pretty), ggplot2 is unbeatable. We will be looking at ggplot2
visualization in the session on _tidyverse_ but as a sneakpeak, you can take
a look at the beautiful figures you'll learn how to make later.

::: {.callout-note collapse="true" icon=false}
#### See the sneakpeak

Look how comparatively little code we need to make beautiful informative figures
which immediately tell a clear story! Stay tuned for later! :)

```{r}
library(ggplot2)
library(dplyr)
```

```{r}
ggplot(penguins) +
  geom_histogram(aes(flipper_len, fill = species), alpha = 0.5) +
  theme_minimal() +
  ggtitle("Distribution of flipper lengths across species")
```

```{r}
ggplot(penguins, aes(flipper_len, body_mass, shape = sex, color = species)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~ species) +
  theme_minimal() +
  ggtitle("Body mass as a function of flipper length across penguin species")
```
:::




# Take home message

It's worth acknowledging that developing code as proper functions, using iteration,
and generally think about solving problems using "proper" program approaches
like that is a lot of work. It might seem that "just copying a bit of code
a couple of times" is easier. In the moment, it actually is.

Except we rarely, if ever, do things only once. We have to come back to old
scripts, update them, or add new steps. Doing this for every single bit of
copy pasted code (sometimes in multiple scripts) is awful, and almost always
results in bugs. Even missing one edit in one copy of a piece of code will
make our results wrong.

**It's always worth investing a bit extra time into extracting repeated
pieces of code into individual functions. It will always result in _less work_
in the long run.**
