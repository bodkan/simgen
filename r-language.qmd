# R programming language

⚠️⚠️⚠️
**This chapter is a work-in-progress!**
⚠️⚠️⚠️

In a wider programming world, R sometimes has a slightly unfortunate reputation
as a badly designed "calculator language". A computing environment which is
maybe good for working with data frames and creating figures, but that's about
it. While certainly very useful for data science, R is a full-blown programming
language which is actually quite powerful even from a purely computer science
perspective.

Although this entire workshop is very firmly standing in the field of data
science and computational population genetics, and we will certainly use R
as a statistical and visualization environment, neglecting the "normal" aspects
of R as a "proper" programming language like any other and, worse still,
not regarding our use of R as programming, can be quite detrimental.
Even when "just" doing data science and statistics, we still use programming
constructs, we need to be aware of data types, algorithmic thinking, etc.
Neglecting these things makes it easy to introduce bugs into our code, make
it hard to find those bugs, and make our programs less efficient even when
they do work.

This chapter will help you get familiar with some of the less obvious aspects
of the R language or programming in general, definitely how data science is
presented in undergratuate courses in life sciences.

Because here's a crucial idea you might not be aware of: even when you're
"just" writing data analysis scripts, even when you're "just" plotting results,
you're still writing programs. You're a programmer. Exercises in this chapter
are designed to make you comfortable with programming and algorithmic thinking.

## Part 1: Atomic data types

```{r}
w1 <- 3.14
x1 <- 42
y1 <- "hello"
z1 <- TRUE
```

```{r}
w1
x1
y1
z1
```

```{r}
mode(w1)
mode(x1)
mode(y1)
mode(z1)
```

## Part 2: Vectors

```{r}
w2 <- c(1.0, 2.72, 3.14)
x2 <- c(1, 13, 42)
y2 <- c("hello", "folks", "!")
z2 <- c(TRUE, FALSE)
```

```{r}
w2
x2
y2
z2
```

```{r}
mode(w2)
mode(x2)
mode(y2)
mode(z2)
```

```{r}
is.vector(w2)
is.vector(x2)
is.vector(y2)
is.vector(z2)
```

Even scalars (singular values) are formally vectors:

```{r}
is.vector(1)
```

This is why we see the [1] index when we type a single number:

```{r}
1
```


In fact, even when we create a vector of length 1, we still get a scalar result:

```{r}
c(1)
```

Try creating a vector with values `1`, `"42"`, and `"hello"`. Can you do it? What happens when you try?

```{r}
mixed_vector1 <- c(1, "42", "hello")
mixed_vector1
```

As you can see, vectors must carry values of just one type. If they don't, they are converted by a straightforward "cascade" of coercions. Can you figure out some of these rules based on different composition of value types you put into the `c()` vector constructing function?

**Hint:** Try creating a vector which has integers and strings, integers and floats, integers and logicals, floats and logicals, floats and strings, and logicals and strings:

```{r}
c(1, "42", "hello")

c(1, 42.13, 123)

c(1, 42, TRUE)

c(1.12, 42.13, FALSE)

c(42.13, "hello")

c(TRUE, "hello")
```




## Part 3: Lists

```{r}
w3 <- list(1.0, 2.72, 3.14)
x3 <- list(1, 13, 42)
y3 <- list("hello", "folks", "!")
z3 <- list(TRUE, FALSE)
```

```{r}
w3
```

```{r}
mode(w3)
```

```{r}
is.list(w3)
```

Lists are vectors!

```{r}
is.vector(w3)
```

But vectors are not lists!

```{r}
is.list(w2)
```


## Data frames

```{r}
df <- data.frame(
  w = c(1.0, 2.72, 3.14),
  x = c(1, 13, 42),
  y = c("hello", "folks", "!"),
  z = c(TRUE, FALSE, FALSE)
)

df
```

Data frames are lists!

```{r}
is.list(df)
```

Two ways of extracting a data-frame column:

- `$` operator (column name as a symbol):

```{r}
df$w
```

- `[[` operator (column name as a string):

```{r}
df[["w"]]
```

Note that the operator must be `[[`, because `[` does something slightly different


