# Working with spatial data


---

[_sf_ cheatsheet!](https://rstudio.github.io/cheatsheets/sf.pdf)

## Setup and data processing

**Read spatial packages:**

```{r}
library(sf)
library(rnaturalearth)
```

**Read other data analysis packages:**

```{r}
library(dplyr)
library(readr)
library(ggplot2)
```

**Read our pre-processed data:**

```{r}
#| eval: false
source("scripts/ibd_utils.R")
```

```{r}
#| echo: false
source(here::here("files/repro/ibd_utils.R"))
```

**Read and process our IBD and metadata using our utility functions:**

```{r}
# download and process the metadata and IBD data set
metadata <- process_metadata(bin_step = 5000)
ibd_segments <- process_ibd()

# combine the IBD table with metadata information
ibd_merged <- join_metadata(ibd_segments, metadata)
```

**Filter metadata to only individuals who have `longitude` and `latitude`
values available (use `filter()`, `!is.na()` and the `&` operator):**

```{r}
metadata <- filter(metadata, !is.na(longitude) & !is.na(latitude))

head(metadata)
```

**Use the function `class()` to check what kind of data type our metadata
is (I know you know it's a data frame, but let's do this for practice):**

```{r}
class(metadata)
```

### Converting non-spatial data to spatial data

**Use function `st_as_sf()` to convert the (non-spatially aware) data frame
object into one that can be interpreted as spatial data. Save the result
as a `sf_metadata` variable. What do you see when you type `sf_metadata`
to your R console and when you run `class()` on that variable? Compare this
to the output you got for the original `metadata` object.** (You'll probably
get an error message, don't worry and move along!)

```{r}
#| error: true
sf_metadata <- st_as_sf(metadata, crs = "EPSG:4326")
```

**The above got you a rather cryptic error. Honestly, even I don't understand
it. But, here's how you fix it: run
`st_as_sf(metadata, coords = c("longitude", "latitude"))` instead.**

**Why do you think this is needed?**

**Hint:** Although it's easy to think that a table with columns "latitude" and
"longitude" is _obviously_ interpretable as spatial data, think about a
situation in which the spatial coordinate columns in your data frame were
called something else (like "lat" / "lon", or "x" / "y", or anything else).

**When you have created the `sf_metadata` successfully, go back to the previous
exercise.**

```{r}
sf_metadata <- st_as_sf(metadata, crs = "EPSG:4326", coords = c("longitude", "latitude"))

head(sf_metadata)
```

---

**The result in `sf_metadata` looks almost like a data frame, right? What
do you get when you run `class(sf_metadata)` again?**

```{r}
class(sf_metadata)
```

---

**The `st_as_sf()` function converts a plain data frame into a "spatially
annotated data frame". Note the additional information about "Dimension",
and "CRS" (Coordinate Reference System "WGS 84"). Take a look at the
[Wikipedia article about WGS 84](https://en.wikipedia.org/wiki/EPSG_Geodetic_Parameter_Dataset)
and decipher what this could mean and why could this be needed.**

---

Unlike _tidyverse_ munging of data frames (where we introduced _ggplot2_ visualizations
at the end), discussing spatial data is much easier to do the other way around,
starting from a visualization.

**It turns out that _sf_ spatial data is basically a normal data frame with
a little bit of extra annotation. This means two things:**

1. **All your _tidyverse_ knowledge applies to spatial data just like it applied
for "normal data frames"!** We'll practice a little bit about _tidyverse_ in
the context of spatial data later.

2. Not only that, but **_ggplot2_ automatically supports plotting of spatial data
points using a dedicated "geom" function `geom_sf()`!**

---

As a reminder, the general pattern of plotting with _ggplot2_ was something
like this:

```
ggplot(DATA_FRAME, aes(MAPPING AESTHETICS, LIKE COLOR ETC.)) +
  geom_...()
```

**Try plotting your `sf_metadata` using the same pattern, but with a new
`geom_sf()`:**


```{r}
sf_metadata %>%
ggplot(aes(color = coverage)) +
  geom_sf()
```

**For simplicity and ease of plotting, use `filter()` to remove individuals
in the metadata who are not from Europe, and save the result to a new
variable `sf_metadata_eur`:**

**Hint:** Remember that even spatial _sf_ data is like any other data frame,
and can therefore be transformed and filtered with every _tidyverse_ function
you already know (`filter()`, `select()`, etc.):**

```{r}
sf_metadata_eur <- sf_metadata %>% filter(continent == "Europe")
```

```{r}
ggplot() +
  geom_sf(data = sf_metadata_eur)
```

In the _ggplot2_ session you've learned about the possibility of visualizing
multiple geoms in the same figure. This concept becomes even more powerful
when visualizing spatial data. **Consider the plot above---we know the points
are from Europe because they form a roughly Europe-shaped cloud. But we want
to add the outline of the European continent, to make the figure look much
nicer.**

**Use the function `ne_countries()` (from the _rnaturalearth_ R package) to
download the spatial coordinates of the European continent. You can do
this by setting its argument `continent = "Europe"`. Save the result into
the variable `sf_countries`:**

```{r}
sf_countries <- ne_countries(continent = "Europe")
```

Let's talk about data types which are possible for spatial data. When you
type the `sf_metadata` into your R console again, you will see the
column `geometry`. What is the data type of this column that you see when
you apply the function `glimpse()` on the `sf_metadata` variable (remember,
although it contains a spatial data object, it is actually still a data
frame too!):**

```{r}
glimpse(sf_metadata)
```

You see a `geometry  <POINT [°]>` data type. This means that the `sf_metadata`
table contains the geometrical objects which are of the type `POINT`---locations
of individuals points in space. This is appropriate for locations of samples
excavated (or sampled) at a particular location.

**What do you get when you run `glimpse()` on the newly downloaded data set
of the European continent in the `sf_countries` variable? To make the output
a little smaller, apply `glimpse()` to the result `%>%` piped from 
`select(sf_countries, geometry):**

```{r}
select(sf_countries, geometry) %>% glimpse
```

You see a data type `geometry <MULTIPOLYGON [°]>`. This is a more complex
spatial geometry type. You might remember [what a "polygon" is](https://en.wikipedia.org/wiki/Polygon)
from school. A `MULTIPOLYGON` is simply a collection of polygons.

There are also other spatial data types. [See this](https://r-spatial.github.io/sf/articles/sf1.html#simple-feature-geometry-types)
for a quick list of possible data types that you might encounter in doing
spatial data analysis.

**To recap the idea of combining multiple geoms on a single _ggplot2_ figure,
let's start just from visualizing a single geom, this time the (what should be)
outlines the continents of the world. You can do this using `geom_sf()`
in exactly the same way how you visualized the metadata, just using
`geom_sf(data = sf_countries)` instead of `geom_sf(data = sf_metadata)`:**

```{r}
ggplot() +
  geom_sf(data = sf_countries)
```

---

The figure above works, but it looks very weird. We should probably restrict the geographic
area of the world we're plotting. For our data set, including "Kamchatka" in
Europe for visualization purposes is pushing it a little bit.

For basic _ggplot2_ figures, we learned to use the `xlim()` function. This
(and the `ylim()` function) operates on the [Cartesian coordinates system](https://en.wikipedia.org/wiki/Cartesian_coordinate_system).
However, spatial data coordinates are not Cartesian. The world is a globe,
and longitude / latitude coordinates (although they might be often written
as plain x and y coordinates) have a different meaning. For that reason,
_ggplot2_ provides a spatial-specific version of `xlim()` and `ylim()`
in the `coord_sf()` function.

**Restrict the geographical range of your spatial figure by adding the layer
`+ coord_sf(xlim = c(-10, 70), ylim = c(30, 80))`:**

```{r}
ggplot() +
  geom_sf(data = sf_countries) +
  coord_sf(xlim = c(-10, 70), ylim = c(35, 73))
```

---

**Now add a new layer to the previous code which will plot the coordinates
of our European spatial data points, using `+ geom_sf(data = sf_metadata_eur)`:**

```{r}
ggplot() +
  geom_sf(data = sf_countries) +
  geom_sf(data = sf_metadata_eur) +
  coord_sf(xlim = c(-10, 70), ylim = c(30, 80))
```

---

Let's map some aesthetics, to practice the concept of modifying the visual
properties of a figure.

**First, try setting `aes(fill = name_en)` in the `geom_sf(data = sf_countries)`.
The visuals will be a bit cluttered, so immediately add also a new layer
`+ guides(fill = "none")`:**

```{r}
ggplot() +
  geom_sf(data = sf_countries, aes(fill = name_en)) +
  geom_sf(data = sf_metadata_eur) +
  coord_sf(xlim = c(-10, 70), ylim = c(30, 80)) +
  guides(fill = "none")
```

---

**Now try setting `aes(color = country)` in `geom_sf(data = sf_metadata_eur)`
(and remove `fill` from `geom_sf(data = sf_countries)`:**

```{r}
ggplot() +
  geom_sf(data = sf_countries) +
  geom_sf(data = sf_metadata_eur, aes(color = country)) +
  coord_sf(xlim = c(-10, 70), ylim = c(30, 80)) +
  guides(color = "none")
```

---

**In practice, 