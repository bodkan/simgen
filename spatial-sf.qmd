# Plotting _tidy_ spatial data


---

### Introduction

**<u>This chapter is a work-in-progress.</u>**

Unlike finished chapters which feature extensive explanations and proper
problem-solution sets of exercises, **the material for this session is still
just a rough tutorial, or a set of little code snippets which demonstrate
the possibilities of visualizing and working with spatial data**.

In light of the work you've done on learning _tidyverse_ and _ggplot2_, the
most important thing to realize is that:

1. **Spatial data in R are nothing but _tidy_ data frames**. Everything you learned
about _tidyverse_ still applies. In fact, those _tidyverse_ concepts are a
requirement to being able to do modern spatial data analysis using R.

2. **Spatial data are visualized using _ggplot2_ concepts of "aesthetics" and
"geoms"**. This means that, again, whatever you learned about _ggplot2_
(plus a tiny bit more) applies also to plotting spatial data.

### Some resources for later self-study

- **Start with an introductory chapter from the book _Spatial Data Science_ about the R
packages _sf_ and _stars_ [available at this link](https://r-spatial.org/book/07-Introsf.html)**.
This chapter includes executable R code, so you can again play around with the
most important concepts interactively (which is the only way to learn anything).

- Basic introductory tutorial on the concept of "simple features" implemented
in the R package _sf_ (which is how _tidyverse_-compatible spatial data are
called, "simple features"): [link](https://r-spatial.github.io/sf/articles/sf1.html)

- A [cheatsheet](https://rstudio.github.io/cheatsheets/sf.pdf) about the R package _sf_

---

**Let's apply the most basic concepts of spatial visualizations using _sf_
on our metadata (and later) IBD data. Just a quick exploratory analysis,
nothing serious!**

## Setup and data processing

**Load spatial packages:**

```{r}
#| message: false
library(sf)
library(rnaturalearth)
```

**Load other data science packages:**

```{r}
#| message: false
library(dplyr)
library(readr)
library(ggplot2)
```

**Source the IBD and metadata processing pipeline functions:**

This will the following functions:

- `process_metadata()`
- `process_ibd()`
- `join_metadata()`

```{r}
#| eval: false
source("scripts/ibd_utils.R")
```

```{r}
#| echo: false
source(here::here("files/repro/ibd_utils.R"))
```

**Read and process IBD and metadata using our utility functions:**

```{r}
#| message: false
#| output: false
# download and process the metadata and IBD data set
metadata <- process_metadata(bin_step = 2500)
ibd_segments <- process_ibd()

# combine the IBD table with metadata information
ibd_merged <- join_metadata(ibd_segments, metadata)
```

This is the same data you worked with during our _tidyverse_ and _ggplot2_
sessions.

---

**Filter metadata to only individuals who have `longitude` and `latitude`
values available (use `filter()`, `!is.na()` and the `&` operator) because
those are the only ones we can do spatial data analysis on:**

```{r}
metadata <- filter(metadata, !is.na(longitude) & !is.na(latitude))

head(metadata)
```

---

**Use the function `class()` to check what kind of data type our metadata
is (I know you know it's a data frame, we'll get to why we're doing this
soon):**

```{r}
class(metadata)
```

Keep this in mind when you run the following code chunks!

---

### Converting non-spatial data to spatial data

**Use the function `st_as_sf()` to convert the (non-spatially aware) data frame
object into one that can be interpreted as spatial data. Save the result
as a `sf_metadata` variable.** (You'll probably get an error message, don't
worry and move along!)

```{r}
#| error: true
sf_metadata <- st_as_sf(metadata, crs = "EPSG:4326")
```

**The above got you a rather cryptic error. Honestly, even I don't think it's as
informative as it should be. But, in any case, you can fix it by running
this instead:**

```{r}
sf_metadata <- st_as_sf(metadata, crs = "EPSG:4326", coords = c("longitude", "latitude"))
```


**Why do you think this is needed?**

**Hint:** Although it's easy to think that a table with columns "latitude" and
"longitude" is _obviously_ interpretable as spatial data, think about a
situation in which the spatial coordinate columns in your data frame were
called something else (like "lat" / "lon", or "x" / "y", or anything else
which is not an "obviously geographical coordinates column").

---

**When you have created the `sf_metadata` successfully, what do you see when
you type `sf_metadata` in your R console? Compare this to the output you got
from typing the original data frame `metadata` object into your R console
earlier.**

```{r}
head(sf_metadata)
```

---

**The result in `sf_metadata` looks almost like a data frame, right? What
do you get when you run `class(sf_metadata)`?**

```{r}
class(sf_metadata)
```

Notice that you still get the `"tbl_df" "tbl" "data.frame"` classes
which all indicate the object of the type "data frame". But there's also
a new data type called `"sf"`.

---

**The `st_as_sf()` function converts a plain data frame into a "spatially
annotated data frame" of the class `sf` (standing for "simple features").
Going into all the details would be too much for this tutorial at this stage,
but please do study the [introductory chapter](https://r-spatial.org/book/07-Introsf.html)
on the website of the R package _sf_.**

---

**Note the additional information about "Dimension",
and "CRS" (Coordinate Reference System "WGS 84") in the output of the
`sf_metadata` table in your R console. Take a look at the
[Wikipedia article about WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System#WGS_84) if you're
interested in knowing more (and you should be!).**

---

## How do "spatial tables" relate to "normal tables"?

Unlike _tidyverse_ munging of data frames (where we introduced _ggplot2_
visualizations after we went through the basics _tidyverse_),
discussing spatial data is much easier to do the
other way around, starting from visualizations before heading into the
technicalities of coordinate reference systems, spatial geometrical transformations,
running geostatistical inferences, etc.

**It turns out that _sf_ spatial data is basically a normal data frame with
a little bit of extra annotation. This means two things:**

1. **All your _tidyverse_ knowledge applies to spatial data just like it applied
for "normal data frames"!** We'll practice a little bit about _tidyverse_ in
the context of spatial data later.

2. Not only that, but **_ggplot2_ automatically supports plotting of spatial data
points using a dedicated "geom" function `geom_sf()`!**

---

As a reminder, the general pattern of plotting with _ggplot2_ was something
like this:

```
ggplot(<DATA FRAME>, aes(<MAPPING AESTHETICS, LIKE COLOR ETC.>)) +
  geom_...() +
  OTHER_LAYERS +
  [...]
```

---

## Plotting points

**Try plotting your `sf_metadata` using the same pattern, but with a new
geom function called `geom_sf()`. Unlike most of your standard _ggplot2_ code,
use the following pattern, however, in which
you specify everything not in the `ggplot()` function but in `geom_sf()` instead.
The `geom_sf()` function is used to visualize every possible kind of 
spatial geometry (some of whom will be shown below).**

```{r}
ggplot() +
  geom_sf(data = sf_metadata)
```

Yes, this figure is nothing to write home about, I know. But it's a start!
Plus, if you squint hard enough, you might see an outline of the world "painted" using
geo-locations of our metadata samples!

---

**Let's talk about data types which are possible for spatial data. When you
type the `sf_metadata` into your R console again, you will see the
column `geometry`. What is the data type of this column that you see when
you apply the function `glimpse()` on the `sf_metadata` variable (remember,
although it contains a spatial data object, it is actually still a data
frame too!):**

```{r}
glimpse(sf_metadata)
```

You see a `geometry  <POINT [Â°]>` data type. This means that the `sf_metadata`
table contains the geometrical objects which are of the type `POINT`. This is
quite an appropriate data type for locations of samples excavated
(or sampled) at a particular location.

## Plotting polygons

**Now, use the function `ne_countries()` (from the _rnaturalearth_ R package) to
download the spatial coordinates of the countries of the world (note that
this package has [many other sources of data](https://cran.r-project.org/web/packages/rnaturalearth/vignettes/rnaturalearth.html)).
Save the result into the variable `sf_countries`:**

```{r}
sf_countries <- ne_countries()
```

---

**What do you get when you run `glimpse()` on the newly downloaded data set
of the continents in the `sf_countries` variable? To make the output
a little smaller, apply `glimpse()` to the result `%>%` piped from 
`select()`, maybe like this:**

```{r}
select(sf_countries, name_en, geometry) %>% glimpse
```

You see a data type `geometry <MULTIPOLYGON [Â°]>`. This is a more complex
spatial geometry type. You might remember [what a "polygon" is](https://en.wikipedia.org/wiki/Polygon)
from school. A `MULTIPOLYGON` is simply a collection of polygons, and it
is a data type used to describe "area-like" spatial geometries,
like outlines of continents or countries.

There are also other spatial data types. [See this](https://r-spatial.github.io/sf/articles/sf1.html#simple-feature-geometry-types)
for a quick list of possible data types that you might encounter in doing
spatial data analysis.

## Plotting multiple types of spatial features


In the _ggplot2_ session earlier you've learned about the possibility of visualizing
multiple geoms in the same figure. This concept becomes even more powerful
when visualizing spatial data. **Consider the following plot again---we know the points
are from planet Earth because they form a roughly world-map-shaped cloud of dots.
But we want to add the outline of the continents to make the figure look 
nicer.**

```{r}
ggplot() +
  geom_sf(data = sf_metadata)
```

---

**To recap the idea of combining multiple geoms on a single _ggplot2_ figure,
let's start just from visualizing a single geom, this time the 
outlines of the countries of the world. You can do this using `geom_sf()`
in exactly the same way how you visualized the metadata, just using
`geom_sf(data = sf_countries)` instead of `geom_sf(data = sf_metadata)`:**

```{r}
ggplot() +
  geom_sf(data = sf_countries)
```


---

**You can visualize multiple geoms simply by adding multiple calls to the
`geom_sf()` function, perhaps like this:**

```{r}
ggplot() +
  geom_sf(data = sf_metadata) +
  geom_sf(data = sf_countries)
```

---

**Oh, again, the order of layering individual geoms matters, of course. Let's
fix this:**

```{r}
ggplot() +
  geom_sf(data = sf_countries) +
  geom_sf(data = sf_metadata)
```

Better (but still not very pretty).

## Zooming in on a map

Let's talk about narrowing down the scale of the world we're looking at.
For basic _ggplot2_ figures, we learned to use the `xlim()` function. This
(and the `ylim()` function) operates on the [Cartesian coordinates system](https://en.wikipedia.org/wiki/Cartesian_coordinate_system).
However, spatial data coordinates are not Cartesian. The world is a globe,
and longitude / latitude coordinates (although they might be often written
as plain x and y coordinates) have a different meaning. For that reason,
_ggplot2_ provides a spatial-specific version of `xlim()` and `ylim()`
in the `coord_sf()` function.

**Restrict the geographical range of your spatial figure by adding the layer
`coord_sf(xlim = c(-25, 60), ylim = c(33, 73))` (note that the units
of numbers given for the limits are longitude and latitude degrees):**

```{r}
ggplot() +
  geom_sf(data = sf_countries) +
  geom_sf(data = sf_metadata) +
  coord_sf(xlim = c(-25, 60), ylim = c(33, 73))
```

We got a more "zoomed-in" version of West Eurasia!

---

**Let's map some aesthetics, to practice the concept of modifying the visual
properties of a figure in the spatial context. Most important thing to note
here is that everything remains _exactly_ the same as with normal _ggplot2_.**

**First, try setting `aes(fill = name_en)` in the `geom_sf(data = sf_countries)`.
The visuals will be a bit cluttered, so immediately add also a new layer
`+ guides(fill = "none")`:**

```{r}
ggplot() +
  geom_sf(data = sf_countries, aes(fill = name_en)) +
  geom_sf(data = sf_metadata) +
  coord_sf(xlim = c(-10, 70), ylim = c(30, 80)) +
  guides(fill = "none")
```

Yikes. This is very hard to look at, but it proves the point of showing that
spatial figures work exactly the same as _ggplot2_ figures and that
colors can be also mapped in the same way using the `aes()` concept of
"aesthetics".

---

**Now try setting `aes(color = country)` in `geom_sf(data = sf_metadata)`
(and remove `fill` from `geom_sf(data = sf_countries)`:**

```{r}
ggplot() +
  geom_sf(data = sf_countries) +
  geom_sf(data = sf_metadata, aes(color = country)) +
  coord_sf(xlim = c(-10, 70), ylim = c(30, 80)) +
  guides(fill = "none")
```

---

**Notice that the legend for each color of our figure above shows a huge number of
countries, despite us "zooming in" on West Eurasia using our `coord_sf()`
layer. For instance, there's no reason to show values for "USA" etc.**

This lets us discuss another topic of spatial data analysis. Just as spatial
figures work exactly like _ggplot2_ figures (because they are!), spatial
data processing works exactly like what we learned about _tidyverse_ (because
spatial data are just data frames!).

**In the chunk of code above, modify this line:**

```{r}
#| eval: false
geom_sf(data = sf_metadata, aes(color = country))
```

**to look like this:**

```{r}
#| eval: false
geom_sf(data = filter(sf_metadata, continent == "Europe"), aes(color = country))
```

So the entire code looks like this:

```{r}
ggplot() +
  geom_sf(data = sf_countries) +
  geom_sf(data = filter(sf_metadata, continent == "Europe"), aes(color = country)) +
  coord_sf(xlim = c(-10, 70), ylim = c(30, 80)) +
  guides(fill = "none")
```

Compare the difference to the previous figure!

**Note:** How exactly you apply _tidyverse_ principles is up to you. If you'd
like to take things step by step, you could also do this and run `filter()` first
to create a new (maybe just a temporary) variable. This can be useful if you
need to do much more _tidyverse_ spatial munging (maybe by chaining together
several `%>%` operations), which would be unreadable inside the `geom_sf(data ...`)
function call. This does the same thing as the code just above (notice that
we first create a new variable and only then use it in `geom_sf(data = ...`):

```{r}
sf_metadata_eur <- filter(sf_metadata, continent == "Europe")

ggplot() +
  geom_sf(data = sf_countries) +
  geom_sf(data = sf_metadata_eur, aes(color = country)) +
  coord_sf(xlim = c(-10, 70), ylim = c(30, 80)) +
  guides(fill = "none")
```

---

**Coloring by countries is maybe not that interesting. How about if we color
the `sf_metadata_eur` by the Y chromosome haplogroup of a given sample?**

```{r}
sf_metadata_eur <- filter(sf_metadata, continent == "Europe")

ggplot() +
  geom_sf(data = sf_countries) +
  geom_sf(data = sf_metadata_eur, aes(color = y_haplo)) +
  coord_sf(xlim = c(-10, 70), ylim = c(30, 80)) +
  guides(fill = "none")
```

---

**We have metadata from many female individuals with (obviously) missing
information about the Y haplogroup. Let's filter for individuals who are male,
saving the results into `sf_metadata_eur_y`:**

```{r}
sf_metadata_eur_y <- filter(sf_metadata, continent == "Europe" & !is.na(y_haplo))

ggplot() +
  geom_sf(data = sf_countries) +
  geom_sf(data = sf_metadata_eur_y, aes(color = y_haplo)) +
  coord_sf(xlim = c(-10, 70), ylim = c(30, 80)) +
  guides(fill = "none")
```

---

The data is cleaner, but no pattern is emerging yet. In our data, we have also
information about the ages of our individuals (for instance, the `age_bin`
column):

```{r}
head(sf_metadata_eur_y)
```

---

**Let's try splitting the data based on an age bin (`+ facet_wrap(~ age_bin)`).
Maybe something interesting pops up?. Additionally, let's remove the grey
background using `+ theme_minimal()`**

```{r}
sf_metadata_eur_y <- filter(sf_metadata, continent == "Europe" & !is.na(y_haplo))

ggplot() +
  geom_sf(data = sf_countries) +
  geom_sf(data = sf_metadata_eur_y, aes(color = y_haplo), size = 1) +
  coord_sf(xlim = c(-10, 70), ylim = c(30, 80)) +
  guides(fill = "none") +
  facet_wrap(~ age_bin)+
  theme_minimal()
```

**I'll leave the historical and evolutionary interpretation to you, at this stage.** ðŸ™‚


## Other _rnaturalearth_ data

First of all, the [_rnaturalearth_](https://cran.r-project.org/web/packages/rnaturalearth/vignettes/rnaturalearth.html)
package is only one of great many possible
sources of spatial data (maybe one of the most convenient to download
into R but still, just one of many).

The good thing is, that the [_sf_](https://r-spatial.github.io/sf/) data
type represents a universal format for storing spatial data sets.
You can even [import](https://r-spatial.github.io/sf/articles/sf2.html) spatial
data from other sources!

That being said, here are a couple of more examples of data provided
by the _rnaturalearth_ resource:

#### `ne_download()`

This function downloads all sorts of spatial data made available
by the public domain [Natural Earth](https://www.naturalearthdata.com)
project.

```{r}
#| output: false
sf_data <- ne_download(scale = "small", type = "land", category = "physical")
```

```{r}
ggplot() +
  geom_sf(data = sf_data) +
  coord_sf(xlim = c(-10, 70), ylim = c(30, 80)) +
  theme_minimal()
```


#### `ne_countries()` (you're already familiar with this)

```{r}
sf_data <- ne_countries()

ggplot() +
  geom_sf(data = sf_data) +
  coord_sf(xlim = c(-10, 70), ylim = c(30, 80)) +
  theme_minimal()
```


#### `ne_coastline()`

```{r}
sf_data <- ne_coastline()

ggplot() +
  geom_sf(data = sf_data) +
  coord_sf(xlim = c(-10, 70), ylim = c(30, 80)) +
  theme_classic()
```



## Plotting lines

<u>**Take the following purely as a demonstration of other _sf_ / _ggplot2_
visualization features. Don't take any of the IBD results as conclusive or
authoritative in any way!**</u>

---

**We will first download the aggregate IBD data and only retain information
relevant for our exploratory analysis here:**

```{r}
#| message: false
ibd_sum <-
  read_tsv("http://tinyurl.com/simgen-ibd-sum") %>%
  filter(distance > 0 & rel == "none") %>%
  select(sample1, sample2, total_ibd, n_ibd)
```

**Let's also process the metadata again, this time adding a more fine-grained
time binning (bins of 1000 years, instead of 5000 years like in our _tidyverse_ session):**

```{r}
#| output: false
sf_metadata <- process_metadata(bin_step = 1000) %>%
  filter(!is.na(longitude) & !is.na(latitude)) %>%
  st_as_sf(crs = "EPSG:4326", coords = c("longitude", "latitude"))
```

---

**Merge the IBD data table with the (spatial!) table of metadata. This
effectively turns the IBD table we read just above this step into a spatial table too, because after this
processing step it will also has spatial geometry columns for both `sample1`
and also `sample2`:**

(This code is very ugly because it was written in haste without much
thinking put into it. It will be polished in a later version.)

::: {.callout-note collapse="true" icon=false}
#### Click to see the rough (and ugly) sketch of how to do this

```{r}
sf_ibd <-
  # take the aggregate IBD table...
  ibd_sum %>%
  # ... join in spatial location and metadata of the sample1...
  inner_join(select(sf_metadata, sample, geometry, age_bin, country), by = join_by(sample1 == sample)) %>%
  rename(point1 = geometry, time_bin1 = age_bin, country1 = country) %>%
  # ... join in spatial location and metadata of the sample2...
  inner_join(select(sf_metadata, sample, geometry, age_bin, country), by = join_by(sample2 == sample)) %>%
  rename(point2 = geometry, time_bin2 = age_bin, country2 = country) %>%
  # remove within-country IBD links
  filter(country1 != country2)
```

```{r}
# use some sf magic to transform pairs of individual points into lines connecting them
sf_ibd$link <- lapply(
  1:nrow(sf_ibd),
  function(i) {
    st_cast(st_union(sf_ibd$point1[[i]], sf_ibd$point2[[i]], by_element = TRUE),
            "LINESTRING")
  }
) %>% st_sfc()
# set the sf table so that the main geometry is this link
st_geometry(sf_ibd) <- "link"
# and remove the point1 and point2 geometries, because they are not needed anymore
sf_ibd$point1 <- NULL
sf_ibd$point2 <- NULL

# make sure the "link geometry" has a properly set Coordinate Reference System
# (otherwise it can't be plotted on a longitude/latitude world map)
st_crs(sf_ibd) <- st_crs(sf_metadata)

sf_ibd <- relocate(sf_ibd, sample1, sample2, total_ibd, link, time_bin1, time_bin2, country1, country2)
```

:::

---

**Now we have a tidy spatially-aware data frame of all IBD aggregate links
saved in a variable `sf_ibd`. When you type it out into your R console,
you can see a new geometry data type `LINESTRING`, which represents connections
between points on a map. In this case, they represent IBD "links" connecting
two individuals across space and time.**

```{r}
sf_ibd
```

**Note:** The `LINESTRING` type is of the format `(lon1 lat1, lon2 lat2)`
(longitude and latitude of `sample1`, and the same for `sample2`).

---

**As with points and polygons, spatial geometries represented by lines
can be visualized in exactly the same way, using the magical _ggplot2_
function `geom_sf()`.**

**Let's use it and some basic _tidyverse_ filtering to look for potentially
interesting historical patterns of IBD sharing across space and time. Specifically,
let's trace the IBD links between different countries and see where else
in the world can they be linked to.**

You could do obviously a much more careful and rigorous exploratory (or
even properly statistical) analysis of this. This is just a quick sketch
of an idea showing how little _ggplot2_ / _sf_ / _tidyverse_ code you
actually need to plot some fascinating data from ancient DNA!

### Where do IBDs link Estonia to?

```{r}
# filter for IBDs with one individual being from Estonia
sf_ibd_target <- filter(sf_ibd, country1 == "Estonia" | country2 == "Estonia")

ggplot() +
  geom_sf(data = sf_countries, alpha = 0.5) +
  geom_sf(data = sf_ibd_target, color = "purple") +
  coord_sf(xlim = c(-25, 100), ylim = c(30, 80)) +
  guides(fill = "none") +
  theme_bw() +
  facet_wrap(~ time_bin2) +
  ggtitle("One IBD 'anchored' in Estonia, the other elsewhere in the world",
          subtitle = "Individual panels show time windows [years BP]")
```



### Where do IBDs link Ukraine to?

The time bin **(4000,5000]** is very cool I think---Yamnaya migration!

```{r}
# filter for IBDs with one individual being from Ukraine
sf_ibd_target <- filter(sf_ibd, country1 == "Ukraine" | country2 == "Ukraine")

ggplot() +
  geom_sf(data = sf_countries, alpha = 0.5) +
  geom_sf(data = sf_ibd_target, color = "purple") +
  coord_sf(xlim = c(-25, 100), ylim = c(30, 80)) +
  guides(fill = "none") +
  theme_bw() +
  facet_wrap(~ time_bin2) +
  ggtitle("One IBD 'anchored' in Estonia, the other elsewhere in the world",
          subtitle = "Individual panels show time windows [years BP]")
```



#### Where do IBDs link Spain to?


Again, the time bin **(4000,5000]** is consistent with
[this study](https://english.elpais.com/elpais/2018/10/03/inenglish/1538568010_930565.html) on the impact of the Yamnaya migration on the populations
of Iberia.

```{r}
# filter for IBDs with one individual being from Spain
sf_ibd_target <- filter(sf_ibd, country1 == "Spain" | country2 == "Spain")

ggplot() +
  geom_sf(data = sf_countries, alpha = 0.5) +
  geom_sf(data = sf_ibd_target, color = "purple") +
  coord_sf(xlim = c(-25, 100), ylim = c(30, 80)) +
  guides(fill = "none") +
  theme_bw() +
  facet_wrap(~ time_bin2) +
  ggtitle("One IBD 'anchored' in Estonia, the other elsewhere in the world",
          subtitle = "Individual panels show time windows [years BP]")
```



### Where do IBDs link Denmark to?

Very clear evidence of the Viking era in the **(0,1000]** years BP time bin,
I think.

```{r}
# filter for IBDs with one individual being from Denmark
sf_ibd_target <- filter(sf_ibd, country1 == "Denmark" | country2 == "Denmark")

ggplot() +
  geom_sf(data = sf_countries, alpha = 0.5) +
  geom_sf(data = sf_ibd_target, color = "purple") +
  coord_sf(xlim = c(-25, 100), ylim = c(30, 80)) +
  guides(fill = "none") +
  theme_bw() +
  facet_wrap(~ time_bin2) +
  ggtitle("One IBD 'anchored' in Estonia, the other elsewhere in the world",
          subtitle = "Individual panels show time windows [years BP]")
```

