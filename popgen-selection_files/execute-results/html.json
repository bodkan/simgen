{
  "hash": "d3db71d93dca62b4d842de1fa4a09b4b",
  "result": {
    "engine": "knitr",
    "markdown": "---\nfilters: \n - collapse-callout.lua\n---\n\n\n\n# Natural selection\n\n---\n\n**Note:** Unfortunately, the most recent SLiM v4.3 is [a little broken](https://github.com/MesserLab/SLiM/issues/495),\nlargely sabotaging the second half of this exercise in which _slendr_ uses SLiM\nfor non-neutral simulations. That said, the first half of the exercise works\nperfectly fine and, once SLiM v5.0 comes out (soon), everything from the first\nhalf will apply to the selection simulations. Alternatively, if you have the\noption, use SLiM 4.2.x.\n\n---\n\nThe primary motivation for designing _slendr_ was to make demographic modelling\nin R as trivially easy and fast as possible, focusing exclusively on neutral\nmodels. However, as _slendr_ became popular, people have been asking for\nthe possibility of simulating natural selection. After all, a large\npart of _slendr_'s functionality deals with population genetic [models across\ngeographical landscapes](https://www.slendr.net/articles/vignette-06-locations.html),\nwhich requires SLiM. So why not support selection simulations using _slendr_\nas well?\n\nIn December 2024 I caved in and added support for modifying\n_slendr_ demographic models with bits of SLiM code, which allows simulating\npretty much any arbitrary selection scenario you might be interested in. \n\nThis exercise is a quick demonstration of how this works and how you might\nsimulate selection using _slendr_. We will do this using another toy\nmodel of ancient human history, which we will first use as a basis for simulating\nthe frequency trajectory of an allele under positive selection, and then implementing a toy selection scan using Tajima's D.\n\nTo speed things up, **create a new `selection.R` script and copy the following\ncode as a starting point for this exercise**:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(slendr)\ninit_env(quiet = TRUE)\n\n# This line sources a script in which I provide a few useful helper functions\n# which you can use in this exercise\nsource(here::here(\"utils.R\"))\n\n# African ancestral population\nafr <- population(\"AFR\", time = 65000, N = 5000)\n\n# First migrants out of Africa\nooa <- population(\"OOA\", parent = afr, time = 60000, N = 5000, remove = 27000) %>%\n  resize(N = 2000, time = 40000, how = \"step\")\n\n# Eastern hunter-gatherers\nehg <- population(\"EHG\", parent = ooa, time = 28000, N = 5000, remove = 6000)\n\n# European population\neur <- population(\"EUR\", parent = ehg, time = 25000, N = 5000) %>%\n  resize(N = 10000, how = \"exponential\", time = 5000, end = 0)\n\n# Anatolian farmers\nana <- population(\"ANA\", time = 28000, N = 5000, parent = ooa, remove = 4000)\n\n# Yamnaya steppe population\nyam <- population(\"YAM\", time = 8000, N = 5000, parent = ehg, remove = 2500)\n\n# Define gene-flow events\ngf <- list(\n  gene_flow(from = ana, to = yam, rate = 0.75, start = 7500, end = 6000),\n  gene_flow(from = ana, to = eur, rate = 0.5, start = 6000, end = 5000),\n  gene_flow(from = yam, to = eur, rate = 0.6, start = 4000, end = 3500)\n)\n\n# Compile all populations into a single slendr model object\nmodel <- compile_model(\n  populations = list(afr, ooa, ehg, eur, ana, yam),\n  gene_flow = gf, generation_time = 30\n)\n\n# Schedule the sampling from four European populations roughly before their\n# disappearance (or before the end of the simulation)\nschedule <- rbind(\n  schedule_sampling(model, times = 0, list(eur, 50)),\n  schedule_sampling(model, times = 6000, list(ehg, 50)),\n  schedule_sampling(model, times = 4000, list(ana, 50)),\n  schedule_sampling(model, times = 2500, list(yam, 50))\n)\n```\n:::\n\n\n\n**Next, visualize the demographic model.** If you did a bit of work in human\npopulation genetics, you might recognize it as a very simplified model\nof demographic history of Europe over the past 50 thousand years or so.\nAs you can see, we are recording 50 individuals from four populations -- for\nEuropeans we sample 50 individuals at \"present-day\", for the remaining populations\nwe're recording 50 individuals just before their disappearance. Also note that\nthere's quite a bit of gene-flow! This was an important thing we've learned about\nhuman history in the past 10 years or so -- everyone is mixed with pretty much\neveryone, there isn't (and never was) anything as a \"pure population\".\n\n::: {.aside}\n**Note:** We didn't discuss it earlier, but _slendr_ also provides the option to\nspecify a `remove =` argument in a `population()` call which instructs the\nsimulation engine to delete a population from a simulation at a given point.\nFor our `msprime()` simulations in earlier examples it wasn't really important,\nbut for the `slim()` simulation we will be running below, we want to make a\npopulation extinct at a certain timepoint. Which is why our ancient populations\nin the starting script model have the `remove =` parameter specified.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_model(model, proportions = TRUE, samples = schedule)\n```\n\n::: {.cell-output-display}\n![](popgen-selection_files/figure-html/unnamed-chunk-2-1.png){width=576}\n:::\n:::\n\n\n\n\n\n\n### Part 1: Simulating a tree sequence and computing Tajima's D \n\nAlthough the point of this exercise is to simulate selection, let's first\nsimulate a normal neutral model using slendr's `msprime()` engine as a sanity\ncheck. **Simulate 10 Mb of sequence with a recombination rate `1e-8` and a\nsampling `schedule` defined above.** Let's not worry about adding any mutations, just to change things up a little bit. We'll be working with\nbranch-based statistics here (which means adding `mode = \"branch\"` whenever\nwe will be computing a statistic, such as Tajima's D).\n\n::: callout-note\n#### Click to see the solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts <- msprime(model, sequence_length = 10e6, recombination_rate = 1e-8, samples = schedule)\n\nts # no mutations!\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n╔═══════════════════════════╗\n║TreeSequence               ║\n╠═══════════════╤═══════════╣\n║Trees          │      17626║\n╟───────────────┼───────────╢\n║Sequence Length│   10000000║\n╟───────────────┼───────────╢\n║Time Units     │generations║\n╟───────────────┼───────────╢\n║Sample Nodes   │        400║\n╟───────────────┼───────────╢\n║Total Size     │    3.6 MiB║\n╚═══════════════╧═══════════╝\n╔═══════════╤═════╤═════════╤════════════╗\n║Table      │Rows │Size     │Has Metadata║\n╠═══════════╪═════╪═════════╪════════════╣\n║Edges      │77414│  2.4 MiB│          No║\n╟───────────┼─────┼─────────┼────────────╢\n║Individuals│  200│  5.5 KiB│          No║\n╟───────────┼─────┼─────────┼────────────╢\n║Migrations │    0│  8 Bytes│          No║\n╟───────────┼─────┼─────────┼────────────╢\n║Mutations  │    0│ 16 Bytes│          No║\n╟───────────┼─────┼─────────┼────────────╢\n║Nodes      │21993│601.4 KiB│          No║\n╟───────────┼─────┼─────────┼────────────╢\n║Populations│    6│417 Bytes│         Yes║\n╟───────────┼─────┼─────────┼────────────╢\n║Provenances│    1│  3.9 KiB│          No║\n╟───────────┼─────┼─────────┼────────────╢\n║Sites      │    0│ 16 Bytes│          No║\n╚═══════════╧═════╧═════════╧════════════╝\n```\n\n\n:::\n:::\n\n\n:::\n\n**Inspect the table of all individuals recorded in our tree sequence using\nthe function `ts_samples()`, making sure we have all the individuals scheduled\nfor tree-sequence recording.** (Again, there's no such a thing as too many\nsanity checks when doing research!)\n\n::: callout-note\n#### Click to see the solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts_samples(ts)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 200 × 3\n   name    time pop  \n   <chr>  <dbl> <chr>\n 1 EHG_1   6000 EHG  \n 2 EHG_2   6000 EHG  \n 3 EHG_3   6000 EHG  \n 4 EHG_4   6000 EHG  \n 5 EHG_5   6000 EHG  \n 6 EHG_6   6000 EHG  \n 7 EHG_7   6000 EHG  \n 8 EHG_8   6000 EHG  \n 9 EHG_9   6000 EHG  \n10 EHG_10  6000 EHG  \n# ℹ 190 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(dplyr)\nts_samples(ts) %>% group_by(pop, time) %>% tally\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n# Groups:   pop [4]\n  pop    time     n\n  <chr> <dbl> <int>\n1 ANA    4000    50\n2 EHG    6000    50\n3 EUR       0    50\n4 YAM    2500    50\n```\n\n\n:::\n:::\n\n\n:::\n\n\nAs you've already learned in an earlier exercise, _tskit_ functions in _slendr_\ngenerally operate on vectors\n(or lists) of individual names, like those produced by `ts_names()` above.\n**Get a vector of names of individuals in every population recorded in the\ntree sequence, then use this to compute Tajima's D using the _slendr_ function\n`ts_tajima()`.** (Use the same approach as you have with `ts_diversity()` or \n`ts_divergence()` above, using the list of names of individuals as the\n`sample_sets =` argument for `ts_tajima()`). **Do you see any striking\ndifferences in the Tajima's D values across populations? Check [this](https://en.wikipedia.org/wiki/Tajima%27s_D#Interpreting_Tajima's_D)\nfor some general guidance.**\n\n::: callout-note\n#### Click to see the solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamples <- ts_names(ts, split = \"pop\")\nsamples\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$ANA\n [1] \"ANA_1\"  \"ANA_2\"  \"ANA_3\"  \"ANA_4\"  \"ANA_5\"  \"ANA_6\"  \"ANA_7\"  \"ANA_8\" \n [9] \"ANA_9\"  \"ANA_10\" \"ANA_11\" \"ANA_12\" \"ANA_13\" \"ANA_14\" \"ANA_15\" \"ANA_16\"\n[17] \"ANA_17\" \"ANA_18\" \"ANA_19\" \"ANA_20\" \"ANA_21\" \"ANA_22\" \"ANA_23\" \"ANA_24\"\n[25] \"ANA_25\" \"ANA_26\" \"ANA_27\" \"ANA_28\" \"ANA_29\" \"ANA_30\" \"ANA_31\" \"ANA_32\"\n[33] \"ANA_33\" \"ANA_34\" \"ANA_35\" \"ANA_36\" \"ANA_37\" \"ANA_38\" \"ANA_39\" \"ANA_40\"\n[41] \"ANA_41\" \"ANA_42\" \"ANA_43\" \"ANA_44\" \"ANA_45\" \"ANA_46\" \"ANA_47\" \"ANA_48\"\n[49] \"ANA_49\" \"ANA_50\"\n\n$EHG\n [1] \"EHG_1\"  \"EHG_2\"  \"EHG_3\"  \"EHG_4\"  \"EHG_5\"  \"EHG_6\"  \"EHG_7\"  \"EHG_8\" \n [9] \"EHG_9\"  \"EHG_10\" \"EHG_11\" \"EHG_12\" \"EHG_13\" \"EHG_14\" \"EHG_15\" \"EHG_16\"\n[17] \"EHG_17\" \"EHG_18\" \"EHG_19\" \"EHG_20\" \"EHG_21\" \"EHG_22\" \"EHG_23\" \"EHG_24\"\n[25] \"EHG_25\" \"EHG_26\" \"EHG_27\" \"EHG_28\" \"EHG_29\" \"EHG_30\" \"EHG_31\" \"EHG_32\"\n[33] \"EHG_33\" \"EHG_34\" \"EHG_35\" \"EHG_36\" \"EHG_37\" \"EHG_38\" \"EHG_39\" \"EHG_40\"\n[41] \"EHG_41\" \"EHG_42\" \"EHG_43\" \"EHG_44\" \"EHG_45\" \"EHG_46\" \"EHG_47\" \"EHG_48\"\n[49] \"EHG_49\" \"EHG_50\"\n\n$EUR\n [1] \"EUR_1\"  \"EUR_2\"  \"EUR_3\"  \"EUR_4\"  \"EUR_5\"  \"EUR_6\"  \"EUR_7\"  \"EUR_8\" \n [9] \"EUR_9\"  \"EUR_10\" \"EUR_11\" \"EUR_12\" \"EUR_13\" \"EUR_14\" \"EUR_15\" \"EUR_16\"\n[17] \"EUR_17\" \"EUR_18\" \"EUR_19\" \"EUR_20\" \"EUR_21\" \"EUR_22\" \"EUR_23\" \"EUR_24\"\n[25] \"EUR_25\" \"EUR_26\" \"EUR_27\" \"EUR_28\" \"EUR_29\" \"EUR_30\" \"EUR_31\" \"EUR_32\"\n[33] \"EUR_33\" \"EUR_34\" \"EUR_35\" \"EUR_36\" \"EUR_37\" \"EUR_38\" \"EUR_39\" \"EUR_40\"\n[41] \"EUR_41\" \"EUR_42\" \"EUR_43\" \"EUR_44\" \"EUR_45\" \"EUR_46\" \"EUR_47\" \"EUR_48\"\n[49] \"EUR_49\" \"EUR_50\"\n\n$YAM\n [1] \"YAM_1\"  \"YAM_2\"  \"YAM_3\"  \"YAM_4\"  \"YAM_5\"  \"YAM_6\"  \"YAM_7\"  \"YAM_8\" \n [9] \"YAM_9\"  \"YAM_10\" \"YAM_11\" \"YAM_12\" \"YAM_13\" \"YAM_14\" \"YAM_15\" \"YAM_16\"\n[17] \"YAM_17\" \"YAM_18\" \"YAM_19\" \"YAM_20\" \"YAM_21\" \"YAM_22\" \"YAM_23\" \"YAM_24\"\n[25] \"YAM_25\" \"YAM_26\" \"YAM_27\" \"YAM_28\" \"YAM_29\" \"YAM_30\" \"YAM_31\" \"YAM_32\"\n[33] \"YAM_33\" \"YAM_34\" \"YAM_35\" \"YAM_36\" \"YAM_37\" \"YAM_38\" \"YAM_39\" \"YAM_40\"\n[41] \"YAM_41\" \"YAM_42\" \"YAM_43\" \"YAM_44\" \"YAM_45\" \"YAM_46\" \"YAM_47\" \"YAM_48\"\n[49] \"YAM_49\" \"YAM_50\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Compute genome-wide Tajima's D for each population -- note that we don't\n# expect to see any significant differences because no population experienced\n# natural selection (yet)\nts_tajima(ts, sample_sets = samples, mode = \"branch\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  set         D\n  <chr>   <dbl>\n1 ANA    0.0543\n2 EHG    0.0546\n3 EUR   -0.487 \n4 YAM   -0.171 \n```\n\n\n:::\n:::\n\n\n:::\n\n\n\n\n## Part 2: Computing Tajima's D in windows\n\nLet's take this one step forward. Even if there is a locus under positive selection\nsomewhere along our chromosome, it might be quite unlikely that we would find a\nTajima's D value significant enough for the entire chromosome (which is basically\nwhat we did in Part 1 now). Fortunately, thanks to the flexibility of\nthe _tskit_ module, the _slendr_ function  `ts_tajima()` has an argument\n`windows =`, which allows us to specify the coordinates of windows into which\na sequence should be broken into, with Tajima's D computed separately for each\nwindow. Perhaps this will allow us to see the impact of positive selection\nafter we get to adding selection to our model. So let's first built some code\ntowards that.\n\n**Define a variable `windows` which will contain a vector of coordinates of\n100 windows, starting at position `0`, and ending at position `10e6` (i.e., the end\nof our chromosome). Then provide this variable as the `windows =` argument of\n`ts_tajima()` on a new, separate line of your script. Save the result of\n`ts_tajima()` into the variable `tajima_wins`, and inspect its contents in the\nR console.**\n\n**Hint:** You can use the R function `seq()` and its argument `length.out = 100`,\nto create the coordinates of window boundaries very easily.\n\n::: callout-note\n#### Click to see the solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pre-compute genomic windows for window-based computation of Tajima's D\nwindows <- round(seq(0, ts$sequence_length, length.out = 100))\nwindows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1]        0   101010   202020   303030   404040   505051   606061   707071\n  [9]   808081   909091  1010101  1111111  1212121  1313131  1414141  1515152\n [17]  1616162  1717172  1818182  1919192  2020202  2121212  2222222  2323232\n [25]  2424242  2525253  2626263  2727273  2828283  2929293  3030303  3131313\n [33]  3232323  3333333  3434343  3535354  3636364  3737374  3838384  3939394\n [41]  4040404  4141414  4242424  4343434  4444444  4545455  4646465  4747475\n [49]  4848485  4949495  5050505  5151515  5252525  5353535  5454545  5555556\n [57]  5656566  5757576  5858586  5959596  6060606  6161616  6262626  6363636\n [65]  6464646  6565657  6666667  6767677  6868687  6969697  7070707  7171717\n [73]  7272727  7373737  7474747  7575758  7676768  7777778  7878788  7979798\n [81]  8080808  8181818  8282828  8383838  8484848  8585859  8686869  8787879\n [89]  8888889  8989899  9090909  9191919  9292929  9393939  9494949  9595960\n [97]  9696970  9797980  9898990 10000000\n```\n\n\n:::\n\n```{.r .cell-code}\n# Compute genome-wide Tajima's D for each population in individual windows\ntajima_wins <- ts_tajima(ts, sample_sets = samples, windows = windows, mode = \"branch\")\ntajima_wins\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  set   D           \n  <chr> <named list>\n1 ANA   <dbl [99]>  \n2 EHG   <dbl [99]>  \n3 EUR   <dbl [99]>  \n4 YAM   <dbl [99]>  \n```\n\n\n:::\n\n```{.r .cell-code}\n# You can see that the format of the result is slightly strange, with the\n# `D` column containing a vector of numbers (this is done for conciseness)\ntajima_wins[1, ]$D\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`1`\n [1] -0.471111021  1.035707354  0.119736082  0.786748182  0.022123431\n [6]  0.887580362  0.185720413  0.207372944  0.737180033  0.552059410\n[11]  0.083173221  1.265596551  1.031116337  0.100943595  0.777587567\n[16]  0.134756031  0.163328304  0.305238881  1.199490530  0.193565111\n[21] -0.288148385 -0.579694375 -0.377831664  0.376381736 -0.211749928\n[26]  0.363588253  0.104295385  0.818714183 -0.624460869  0.590906678\n[31]  0.158412428 -0.675086445 -0.192009603 -0.696101174 -0.310887580\n[36]  0.253710103 -0.751518487  0.001691092 -0.150552268 -1.313460730\n[41] -0.493968645 -0.294470766  0.373408744  0.557872129 -0.298863811\n[46]  0.593079994 -0.834306793 -0.409688326 -0.273048024  0.025394688\n[51]  0.842116221  0.596438716  0.423707884  0.747511832 -0.375040766\n[56] -0.186266644  0.815331956  0.416940697  0.198879271 -0.422840111\n[61] -1.759342761 -0.851932964 -0.509539835 -0.295424834  0.394284803\n[66]  0.606600131 -0.467114283  0.526933522 -0.049186424  0.985616026\n[71] -0.433973758 -0.947358482  1.092440731  0.121316477  1.013923034\n[76]  0.617638769 -0.738097550 -0.698537115 -0.129565732  0.714702635\n[81] -0.165535826  0.292633512 -0.680659980 -1.047185676 -0.594371340\n[86]  0.188749595  0.072334247 -0.324639144  0.209057835 -0.242831535\n[91] -0.300344318 -0.495965639 -1.230566620 -0.186480598  0.086898039\n[96] -1.378904620  0.104837543 -1.397505712 -0.248631731\n```\n\n\n:::\n:::\n\n\n:::\n\nThe default output format of `ts_tajima()` is not super user-friendly. **Process\nthe result using a helper function `process_tajima(tajima_wins)` that I provided\nfor you (perhaps save it as `tajima_df`), and visualize it using another\nof my helper functions `plot_tajima(tajima_df)`.**\n\n::: aside\n**Note:** Making the `process_tajima()` and `plot_tajima()` function available\nin your R code is the purpose of the `source(here::here(\"utils.R\"))` command\nat the beginning of your script for this exercise.\n:::\n\n::: callout-note\n#### Click to see the solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The helper function `process_tajima()` reformats the results into a normal\n# data frame, this time with a new column `window` which indicates the index\n# of the window that each `D` value was computed in\ntajima_df <- process_tajima(tajima_wins)\ntajima_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 396 × 3\n   set         D window\n   <chr>   <dbl>  <int>\n 1 ANA   -0.471       1\n 2 ANA    1.04        2\n 3 ANA    0.120       3\n 4 ANA    0.787       4\n 5 ANA    0.0221      5\n 6 ANA    0.888       6\n 7 ANA    0.186       7\n 8 ANA    0.207       8\n 9 ANA    0.737       9\n10 ANA    0.552      10\n# ℹ 386 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# Now let's visualize the window-based Tajima's D along the simulated genome\n# using another helper function `plot_tajima()`\nplot_tajima(tajima_df)\n```\n\n::: {.cell-output-display}\n![](popgen-selection_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\nIt's no surprise that we don't see any Tajima's D outliers in any of our\nwindows, because we're still working with a tree sequence produced by our\na purely neutral simulation. But we have everything set up for the next part,\nin which we will add selection acting on a beneficial allele.\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Part 3: Adding positive selection to the base demographic model\n\nAlthough primarily designed for neutral demographic models, _slendr_ allows\noptional simulation of natural selection by providing a \"SLiM extension code\nsnippet\" with customization SLiM code as an optional argument `extension =`\nof `compile_model()` (a function you're closely familiar with at this point).\n\nUnfortunately we don't have any space to explain SLiM here (and I have no idea,\nat the time of writing, whether or not you will have worked with SLiM earlier\nin this workshop). Suffice to say that SLiM is another very popular population\ngenetic simulator software which allows simulation of selection, and which\nrequires you to write custom code in a different programming language called\nEidos.\n\n\n**Take a look at the file `slim_extension.txt` provided in your working\ndirectory (it's also part of the GitHub repository [here](https://github.com/bodkan/simgen/blob/main/slim_extension.txt)).\nIf you worked with SLiM before, glance through the script casually and see\nif it makes any sense to you. If you have not worked with SLiM before,\nlook for the strange `{{elements}}` in curly brackets in the first ten lines\nof the script.** Those are the parameters of the selection model we will be\ncustomizing the standard neutral demographic model we started with in the next step.\n\nSpecifically, when you inspect the `slim_extension.txt` file, you can see\nthat this \"SLiM extension script\" I provided for you has three parameters:\n\n- `origin_pop` -- in which population should a beneficial allele appear,\n- `s` -- what should be the selection coefficient of the beneficial allele, and\n- `onset_time` -- at which time should the allele appear in the `origin_pop`.\n\nHowever, at the start, the SLiM extension snippet doesn't contain any concrete\nvalues of those parameters, but only their `{{origin_pop}}`, `{{s}}`, and\n`{{onset_time}}` placeholders.\n\n**Use the _slendr_ function `substitute_values()` to substitute concrete values\nfor those parameters like this:**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nextension <- substitute_values(\n  template = here::here(\"slim_extension.txt\"),\n  origin_pop = \"EUR\",\n  s = 0.15,\n  onset_time = 12000\n)\nextension\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/var/folders/h2/qs0z_44x2vn2sskqc0cct7540000gn/T//RtmpAlSXaq/file48a86e390cee\"\n```\n\n\n:::\n:::\n\n\n\nYou can see that `substitute_values()` returned a path to a file. **Take a look\nat that file in your terminal -- you should see each of the three `{{placeholder}}`\nparameters replaced with a concrete given value.**\n\n::: callout-note\n#### Click to see the solution\n\nLet's take a look at the first 15 lines of the extension file before and\nafter calling `substitute_values()`. We'll do this in R for simplicity, but\nyou can use `less` in plain unix terminal.\n\n**Before -- see the {{placeholder}} parameters in their original form:**\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n// Define model constants (to be substituted) all in one place\n// (each {{placeholder}} will be replaced by a value passed from R).\n// Note that string constant template patterns are surrounded by \"quotes\"!\ninitialize() {\n    defineConstant(\"s\", {{s}});\n    defineConstant(\"onset_time\", {{onset_time}});\n    defineConstant(\"origin_pop\", \"{{origin_pop}}\");\n\n    // compose a trajectory file based on given parameters\n    defineConstant(\"traj_file\", PATH + \"/\" + \"trajectory.tsv\");\n}\n```\n\n\n:::\n:::\n\n\n\n**After -- see the {{placeholder}} parameters with concrete values!**\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n// Define model constants (to be substituted) all in one place\n// (each {{placeholder}} will be replaced by a value passed from R).\n// Note that string constant template patterns are surrounded by \"quotes\"!\ninitialize() {\n    defineConstant(\"s\", 0.15);\n    defineConstant(\"onset_time\", 12000);\n    defineConstant(\"origin_pop\", \"EUR\");\n\n    // compose a trajectory file based on given parameters\n    defineConstant(\"traj_file\", PATH + \"/\" + \"trajectory.tsv\");\n}\n```\n\n\n:::\n:::\n\n\n:::\n\nAnd that's all the extra work we need to turn our purely neutral demographic\n_slendr_ model into a model which includes natural selection! (In this case,\nonly a simple selection acting on a single locus, as you'll see later, but\nthis can be generalized to any imaginable selection scenario.)\n\nHow do we use the SLiM extension for our simulation? It's very simple -- we\njust have to provide the `extension` variable as an additional argument of\ngood old `compile_model()`. This will compile a new _slendr_ model which will\nnow include the new functionality for simulating natural selection:\n\n**Compile a new `model` of the history of populations `afr`, `ooa`, `ehg`, \netc., by following the instructions above, providing a new `extension =`\nargument to the `compile_model()` function.**\n\n::: callout-note\n#### Click to see the solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel <- compile_model(\n  populations = list(afr, ooa, ehg, eur, ana, yam),\n  gene_flow = gf, generation_time = 30,\n  extension = extension   # <======== this is missing in the neutral example!\n)\n```\n:::\n\n\n:::\n\n\n\n## Part 4: Running a selection simulation using `slim()`\n\nNow we can finally run our selection simulation!\n\nThere are two modifications to our previous simulation workflows:\n\n1. Because we need to run a non-neutral simulation, we have to switch from using\nthe `msprime()` _slendr_ engine to `slim()`. The latter can still interpret the\nsame demographic model we programmed in R, just like the `msprime()` engine can,\nbut will run the model using SLiM (and thus leveraging the new SLiM extension code\nthat we have customized using `substitute_values()` above). We simply do this by\nswitching from this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts <- msprime(model, sequence_length = 10e6, recombination_rate = 1e-8, samples = schedule)\n```\n:::\n\n\n\nto this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts <- slim(model, sequence_length = 10e6, recombination_rate = 1e-8, samples = schedule)\n```\n:::\n\n\n\nAs you can see, you don't have to modify anything in your model code, just\nswitching from `msprime` to `slim` in the line of code which produces the\nsimulation result.\n\n2. The customized model will not only produce a tree sequence, but will\nalso generate a table of allele frequencies in each population (SLiM experts\nmight have noticed the revelant SLiM code when they were inspecting\n[`slim_extension.txt`](https://github.com/bodkan/simgen/blob/main/slim_extension.txt)). We need to be able to load both of these files after\nthe simulation and thus need a path to a location we can find those files.\nWe can do this by calling the `slim()` function as `path <- slim(..., path = TRUE)`\n(so with the extra `path =` argument). This will return a path to where the\n`slim()` engine saved all files with our desired results.\n\n**Run a simulation from the modified model of selection with the `slim()` engine\nas instructed in points number 1. and 2. above, then use the `list.files(path)`\nfunction in R to take a look in the directory. Which files were produced by\nthe simulation?**\n\n::: callout-note\n#### Click to see the solution (you have a working SLiM installation)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tstart <- Sys.time()\npath <- slim(model, sequence_length = 10e6, recombination_rate = 1e-8, samples = schedule, path = TRUE, random_seed = 59879916)\n# tend <- Sys.time()\n# tend - tstart # Time difference of 38.82014 secs\n\n# We can verify that the path not only contains a tree-sequence file but also\n# the table of allele frequencies.\nlist.files(path)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"slim.trees\"     \"trajectory.tsv\"\n```\n\n\n:::\n:::\n\n\n\nWe can see that the `slim()` simulation generated a tree-sequence file (just\nlike in previous exercises focused on `msprime()`) but it also created a new\nfile -- this was done by the SLiM customization snippet we provided to\n`compile_model()`.\n:::\n\n::: callout-note\n#### Click to see the solution (you don't have a working SLiM installation _or_ the simulation takes too long)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# If you don't have SLiM set up, just use the simulated results from my own\n# run of the same simulation\npath <- here::here(\"data/selection\")\n\n# We can verify that the path not only contains a tree-sequence file but also\n# the table of allele frequencies.\nlist.files(path)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"slim.trees\"     \"trajectory.tsv\"\n```\n\n\n:::\n:::\n\n\n\nWe can see that the `slim()` simulation generated a tree-sequence file (just\nlike in previous exercises focused on `msprime()`) but it also created a new\nfile -- this was done by the SLiM customization snippet we provided to\n`compile_model()`.\n:::\n\n## Part 5: Investigating allele frequency trajectories\n\n**Use another helper function `read_trajectory(path)` which I provided for this\nexercise to read the simulated frequency trajectories of the positively\nselected mutation in all of our populations into a variable `traj_df`. Then\nrun a second helper function `plot_trajectory(traj_df)` to inspect the trajectories\nvisually.**\n\n**Recall that you used the function `substitute_values()` to parametrize your\nselection model so that the allele under selection occurs in Europeans 15 thousand\nyears ago, and is programmed to be under very strong selection of $s = 0.15$.\nDo the trajectories visualized by `plot_trajectory()` make sense given the\ndemographic model of European prehistory plotted above?**\n\n::: callout-note\n#### Click to see the solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntraj_df <- read_trajectory(path)\ntraj_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,604 × 4\n    time pop      freq onset\n   <dbl> <fct>   <dbl> <dbl>\n 1 11990 EHG    0      12000\n 2 11990 ANA    0      12000\n 3 11990 EUR    0.0001 12000\n 4 11990 YAM   NA      12000\n 5 11960 EHG    0      12000\n 6 11960 ANA    0      12000\n 7 11960 EUR    0.0001 12000\n 8 11960 YAM   NA      12000\n 9 11930 EHG    0      12000\n10 11930 ANA    0      12000\n# ℹ 1,594 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nplot_trajectory(traj_df)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 554 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](popgen-selection_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Comparing the trajectories side-by-side with the demographic model reveals\n# some obvious patterns of both selection and demographic history.\nplot_grid(\n  plot_model(model),\n  plot_trajectory(traj_df),\n  nrow = 1, rel_widths = c(0.7, 1)\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 554 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](popgen-selection_files/figure-html/unnamed-chunk-16-2.png){width=672}\n:::\n:::\n\n\n\nWe can see that the beneficial allele which appeared in the European population\nwas under _extremely strong selection_ (look how its allele frequency shoots\nup immediately after its first appearance!). However, we can also se how\nthe following demographic history with multiple admixture events kept \"diluting\"\nthe allele frequency (indicated by the dips in the trajectory).\n\nThis is the kind of _slendr_ simulation which could be also very useful for simulation-based\ninference, like we did in the previous exercise. Just imagine having a comparable\naDNA time series data with empirical allele frequency trajectory over time and\nusing it in an ABC setting!\n:::\n\n## Part 6: Tajima's D (genome-wide and window-based) from the selection model\n\nRecall that your simulation run saved results in the location stored in the\n`path` variable:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist.files(path)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"slim.trees\"     \"trajectory.tsv\"\n```\n\n\n:::\n:::\n\n\n\nFrom this `path`, we've already successfuly investigated the frequency trajectories.\n\nNow let's compute Tajima's D on the tree sequence simulated from our selection\nmodel. Hopefully we should see an interesting pattern in our selection scan?\nFor instance, we don't know yet _where_ in the genome is the putative locus\nunder selection!\n\nTo read a tree sequence simulated with `slim()` by our customized selection setup,\nwe need to do a bit of work. To simplify things a bit, here's the R code which makes\nit possible to do. Just copy it in your `selection.R` script as it is:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's use my own saved simulation results, so that we're all on the\n# same page going forward\npath <- here::here(\"data/selection\")\n\nts <-\n  file.path(path, \"slim.trees\") %>%  # 1. compose full path to the slim.trees file\n  ts_read(model) %>%                 # 2. read the tree sequence file into R\n  ts_recapitate(Ne = 5000, recombination_rate = 1e-8) # 3. perform recapitation\n```\n:::\n\n\n\nVery briefly, because our tree sequence was generated by SLiM, it's very likely\nthat not all genealogies along the simulated genome will be fully coalesced\n(i.e., not all tree will have a single root). To explain why this is the case\nis out of the scope of this session, but read [here](https://tskit.dev/pyslim/docs/latest/tutorial.html) if you're interested\nin learning more. For the time being, it suffices to say that we can pass the\n(uncoalesced) tree sequence into the `ts_recapitate()` function, which then\ntakes a SLiM tree sequence and simulates all necessary \"ancestral history\" that\nwas missing on the uncoalesced trees, thus ensuring that the entire tree\nsequence is fully coalesced and can be correctly computed on.\n\n**Now that you have a `ts` tree sequence object resulting from a new selection\nsimulation run, repeat the analyses of genome-wide and window-based Tajima's D\nfrom _Part 1_ and _Part 2_ of this exercise, again using the provided helper\nfunctions `process_tajima()` and `plot_tajima()`. Can you identify which locus\nhas been the likely focal point of the positive selection? Which population\nshows evidence of selection? Which doesn't and why (look again at the \nvisualization of the demographic model above)?**\n\n::: callout-note\n#### Click to see the solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamples <- ts_names(ts, split = \"pop\")\nsamples\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$ANA\n [1] \"ANA_1\"  \"ANA_2\"  \"ANA_3\"  \"ANA_4\"  \"ANA_5\"  \"ANA_6\"  \"ANA_7\"  \"ANA_8\" \n [9] \"ANA_9\"  \"ANA_10\" \"ANA_11\" \"ANA_12\" \"ANA_13\" \"ANA_14\" \"ANA_15\" \"ANA_16\"\n[17] \"ANA_17\" \"ANA_18\" \"ANA_19\" \"ANA_20\" \"ANA_21\" \"ANA_22\" \"ANA_23\" \"ANA_24\"\n[25] \"ANA_25\" \"ANA_26\" \"ANA_27\" \"ANA_28\" \"ANA_29\" \"ANA_30\" \"ANA_31\" \"ANA_32\"\n[33] \"ANA_33\" \"ANA_34\" \"ANA_35\" \"ANA_36\" \"ANA_37\" \"ANA_38\" \"ANA_39\" \"ANA_40\"\n[41] \"ANA_41\" \"ANA_42\" \"ANA_43\" \"ANA_44\" \"ANA_45\" \"ANA_46\" \"ANA_47\" \"ANA_48\"\n[49] \"ANA_49\" \"ANA_50\"\n\n$EHG\n [1] \"EHG_1\"  \"EHG_2\"  \"EHG_3\"  \"EHG_4\"  \"EHG_5\"  \"EHG_6\"  \"EHG_7\"  \"EHG_8\" \n [9] \"EHG_9\"  \"EHG_10\" \"EHG_11\" \"EHG_12\" \"EHG_13\" \"EHG_14\" \"EHG_15\" \"EHG_16\"\n[17] \"EHG_17\" \"EHG_18\" \"EHG_19\" \"EHG_20\" \"EHG_21\" \"EHG_22\" \"EHG_23\" \"EHG_24\"\n[25] \"EHG_25\" \"EHG_26\" \"EHG_27\" \"EHG_28\" \"EHG_29\" \"EHG_30\" \"EHG_31\" \"EHG_32\"\n[33] \"EHG_33\" \"EHG_34\" \"EHG_35\" \"EHG_36\" \"EHG_37\" \"EHG_38\" \"EHG_39\" \"EHG_40\"\n[41] \"EHG_41\" \"EHG_42\" \"EHG_43\" \"EHG_44\" \"EHG_45\" \"EHG_46\" \"EHG_47\" \"EHG_48\"\n[49] \"EHG_49\" \"EHG_50\"\n\n$EUR\n [1] \"EUR_1\"  \"EUR_2\"  \"EUR_3\"  \"EUR_4\"  \"EUR_5\"  \"EUR_6\"  \"EUR_7\"  \"EUR_8\" \n [9] \"EUR_9\"  \"EUR_10\" \"EUR_11\" \"EUR_12\" \"EUR_13\" \"EUR_14\" \"EUR_15\" \"EUR_16\"\n[17] \"EUR_17\" \"EUR_18\" \"EUR_19\" \"EUR_20\" \"EUR_21\" \"EUR_22\" \"EUR_23\" \"EUR_24\"\n[25] \"EUR_25\" \"EUR_26\" \"EUR_27\" \"EUR_28\" \"EUR_29\" \"EUR_30\" \"EUR_31\" \"EUR_32\"\n[33] \"EUR_33\" \"EUR_34\" \"EUR_35\" \"EUR_36\" \"EUR_37\" \"EUR_38\" \"EUR_39\" \"EUR_40\"\n[41] \"EUR_41\" \"EUR_42\" \"EUR_43\" \"EUR_44\" \"EUR_45\" \"EUR_46\" \"EUR_47\" \"EUR_48\"\n[49] \"EUR_49\" \"EUR_50\"\n\n$YAM\n [1] \"YAM_1\"  \"YAM_2\"  \"YAM_3\"  \"YAM_4\"  \"YAM_5\"  \"YAM_6\"  \"YAM_7\"  \"YAM_8\" \n [9] \"YAM_9\"  \"YAM_10\" \"YAM_11\" \"YAM_12\" \"YAM_13\" \"YAM_14\" \"YAM_15\" \"YAM_16\"\n[17] \"YAM_17\" \"YAM_18\" \"YAM_19\" \"YAM_20\" \"YAM_21\" \"YAM_22\" \"YAM_23\" \"YAM_24\"\n[25] \"YAM_25\" \"YAM_26\" \"YAM_27\" \"YAM_28\" \"YAM_29\" \"YAM_30\" \"YAM_31\" \"YAM_32\"\n[33] \"YAM_33\" \"YAM_34\" \"YAM_35\" \"YAM_36\" \"YAM_37\" \"YAM_38\" \"YAM_39\" \"YAM_40\"\n[41] \"YAM_41\" \"YAM_42\" \"YAM_43\" \"YAM_44\" \"YAM_45\" \"YAM_46\" \"YAM_47\" \"YAM_48\"\n[49] \"YAM_49\" \"YAM_50\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Overall Tajima's D across the 10Mb sequence still doesn't reveal any significant\n# deviations even in case of selection (again, not entirely unsurprising)\nts_tajima(ts, sample_sets = samples, mode = \"branch\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  set         D\n  <chr>   <dbl>\n1 ANA    0.0756\n2 EHG    0.0544\n3 EUR   -0.312 \n4 YAM   -0.297 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# So let's look at the window-based computation again...\nwindows <- as.integer(seq(0, ts$sequence_length, length.out = 100))\n\n# compute genome-wide Tajima's D for each population in individual windows\ntajima_wins <- ts_tajima(ts, sample_sets = samples, windows = windows, mode = \"branch\")\ntajima_df <- process_tajima(tajima_wins)\n\nplot_tajima(tajima_df)\n```\n\n::: {.cell-output-display}\n![](popgen-selection_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\nYou should see a clear dip in Tajima's D around the midpoint of the DNA sequence,\nbut only in Europeans. The beneficial allele appeared in the European population,\nand although the plot of the allele frequency trajectories shows that the selection\ndynamics has been _dramatically_ affected by gene-flow events (generally causing\na repeated \"dilution\" of the selection signal in Europeans), there has never been\ngene-flow (at least in our model) _from_ Europeans to other populations, so the\nbeneficial allele never had a chance to \"make it\" into those populations.\n\n:::\n\n\n\n\n\n\n\n\n\n\n:::::: callout-tip\n## Bonus exercises\n\n\n#### Bonus 1: Examine the pattern of ancestry tracts along the simulated genome\n\n\n::: callout-note\n#### Click to see the solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tracts <- ts_tracts(ts, source = \"ANA\", target = \"EUR\")\n```\n:::\n\n\n:::\n\n\n\n\n\n#### Bonus 2: Investigate the impact of recombination around the selected locus\n\nVary the uniform recombination rate and observe what happens with Tajima's D\nin windows along the genome.\n\n::: callout-note\n#### Click to see the solution\n\nSolution: just modify the value of the `recombination_rate =` argument provided\nto the `slim()` function above.\n:::\n\n\n\n\n\n#### Bonus 3: Simulate origin of the allele in EHG\n\n\nSimulate the origin of the beneficial allele in the EHG population -- what\ndo the trajectories look like now? How does that change the Tajima's D\ndistribution along the genome in our European populations?\n\n::: callout-note\n#### Click to see the solution\n\nUse this extension in the `slim()` call, and repeat the rest of the\nselection-based workflow in this exercise.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nextension <- substitute_values(\n  template = \"slim_extension.txt\",\n  origin_pop = \"EHG\",\n  s = 0.1,\n  onset_time = 12000\n)\nmodel <- compile_model(\n  populations = list(afr, ooa, ehg, eur, ana, yam),\n  gene_flow = gf, generation_time = 30,\n  extension = extension\n)\n```\n:::\n\n\n:::\n\n\n\n#### Bonus 4: Other statistics in windows\n\nAs a practice of your newly acquired tree-sequence computation skills with\n_slendr_, calculate some other statistics in the same windows along the\nsimulated genome, visualize them yourself, and compare the results to the\nwindow-based Tajima's D pattern. For instance, `ts_diversity()`, `ts_divergence()`,\nor `ts_segregating()` might be quite interesting to look at.\n\n::: callout-note\n#### Click to see the solution\n\nUse the same tree sequence file you've computed Tajima's D on, and then\napply the functions `ts_diversity()`, `ts_divergence()`, and `ts_segregating()`\non that tree sequence.\n:::\n\n\n\n\n:::\n<!-- End of Bonus exercises -->\n\n\n\n\n\n\n",
    "supporting": [
      "popgen-selection_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}